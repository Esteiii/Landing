{"ast":null,"code":"import { useRef, useState, useCallback, useEffect } from 'react';\nimport EmblaCarousel from 'embla-carousel';\n\nfunction canUseDOM() {\n  return !!(typeof window !== 'undefined' && window.document && window.document.createElement);\n}\n\nfunction sortAndMapPluginToOptions(plugins) {\n  return plugins.concat().sort(function (a, b) {\n    return a.name > b.name ? 1 : -1;\n  }).map(function (plugin) {\n    return plugin.options;\n  });\n}\n\nfunction arePluginsEqual(pluginsA, pluginsB) {\n  if (pluginsA.length !== pluginsB.length) return false;\n  var areEqual = EmblaCarousel.optionsHandler().areEqual;\n  var optionsA = sortAndMapPluginToOptions(pluginsA);\n  var optionsB = sortAndMapPluginToOptions(pluginsB);\n  return optionsA.every(function (optionA, index) {\n    var optionB = optionsB[index];\n    return areEqual(optionA, optionB);\n  });\n}\n\nfunction useEmblaCarousel(options, plugins) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  if (plugins === void 0) {\n    plugins = [];\n  }\n\n  var optionsHandler = useRef(EmblaCarousel.optionsHandler());\n  var storedOptions = useRef(options);\n  var storedPlugins = useRef(plugins);\n\n  var _a = useState(),\n      embla = _a[0],\n      setEmbla = _a[1];\n\n  var _b = useState(),\n      viewport = _b[0],\n      setViewport = _b[1];\n\n  var reInit = useCallback(function () {\n    if (embla) embla.reInit(storedOptions.current, storedPlugins.current);\n  }, [embla]);\n  useEffect(function () {\n    if (canUseDOM() && viewport) {\n      EmblaCarousel.globalOptions = useEmblaCarousel.globalOptions;\n      var newEmbla_1 = EmblaCarousel(viewport, storedOptions.current, storedPlugins.current);\n      setEmbla(newEmbla_1);\n      return function () {\n        return newEmbla_1.destroy();\n      };\n    } else {\n      setEmbla(undefined);\n    }\n  }, [viewport, setEmbla]);\n  useEffect(function () {\n    if (optionsHandler.current.areEqual(storedOptions.current, options)) return;\n    storedOptions.current = options;\n    reInit();\n  }, [options, reInit]);\n  useEffect(function () {\n    if (arePluginsEqual(storedPlugins.current, plugins)) return;\n    storedPlugins.current = plugins;\n    reInit();\n  }, [plugins, reInit]);\n  return [setViewport, embla];\n}\n\nuseEmblaCarousel.globalOptions = undefined;\nexport { useEmblaCarousel as default };","map":{"version":3,"sources":["src/components/utils.ts","src/components/index.ts"],"names":["canUseDOM","window","a","b","pluginsA","pluginsB","EmblaCarousel","optionsA","sortAndMapPluginToOptions","optionsB","optionB","areEqual","optionsHandler","useRef","storedOptions","storedPlugins","embla","setEmbla","useState","viewport","setViewport","reInit","useCallback","useEffect","useEmblaCarousel","newEmbla_1","arePluginsEqual"],"mappings":"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","sourcesContent":["import EmblaCarousel, { EmblaPluginType } from 'embla-carousel'\n\nexport function canUseDOM(): boolean {\n  return !!(\n    typeof window !== 'undefined' &&\n    window.document &&\n    window.document.createElement\n  )\n}\n\nexport function sortAndMapPluginToOptions(\n  plugins: EmblaPluginType[],\n): EmblaPluginType['options'][] {\n  return plugins\n    .concat()\n    .sort((a, b) => (a.name > b.name ? 1 : -1))\n    .map((plugin) => plugin.options)\n}\n\nexport function arePluginsEqual(\n  pluginsA: EmblaPluginType[],\n  pluginsB: EmblaPluginType[],\n): boolean {\n  if (pluginsA.length !== pluginsB.length) return false\n\n  const { areEqual } = EmblaCarousel.optionsHandler()\n  const optionsA = sortAndMapPluginToOptions(pluginsA)\n  const optionsB = sortAndMapPluginToOptions(pluginsB)\n\n  return optionsA.every((optionA, index) => {\n    const optionB = optionsB[index]\n    return areEqual(optionA, optionB)\n  })\n}\n","import { useRef, useEffect, useState, useCallback } from 'react'\nimport { arePluginsEqual, canUseDOM } from './utils'\nimport EmblaCarousel, {\n  EmblaCarouselType,\n  EmblaOptionsType,\n  EmblaPluginType,\n} from 'embla-carousel'\n\ntype EmblaViewportRefType = <ViewportElement extends HTMLElement>(\n  instance: ViewportElement | null,\n) => void\n\nexport type UseEmblaCarouselType = [\n  EmblaViewportRefType,\n  EmblaCarouselType | undefined,\n]\n\nfunction useEmblaCarousel(\n  options: EmblaOptionsType = {},\n  plugins: EmblaPluginType[] = [],\n): UseEmblaCarouselType {\n  const optionsHandler = useRef(EmblaCarousel.optionsHandler())\n  const storedOptions = useRef(options)\n  const storedPlugins = useRef(plugins)\n  const [embla, setEmbla] = useState<EmblaCarouselType>()\n  const [viewport, setViewport] = useState<HTMLElement>()\n\n  const reInit = useCallback(() => {\n    if (embla) embla.reInit(storedOptions.current, storedPlugins.current)\n  }, [embla])\n\n  useEffect(() => {\n    if (canUseDOM() && viewport) {\n      EmblaCarousel.globalOptions = useEmblaCarousel.globalOptions\n      const newEmbla = EmblaCarousel(\n        viewport,\n        storedOptions.current,\n        storedPlugins.current,\n      )\n      setEmbla(newEmbla)\n      return () => newEmbla.destroy()\n    } else {\n      setEmbla(undefined)\n    }\n  }, [viewport, setEmbla])\n\n  useEffect(() => {\n    if (optionsHandler.current.areEqual(storedOptions.current, options)) return\n\n    storedOptions.current = options\n    reInit()\n  }, [options, reInit])\n\n  useEffect(() => {\n    if (arePluginsEqual(storedPlugins.current, plugins)) return\n\n    storedPlugins.current = plugins\n    reInit()\n  }, [plugins, reInit])\n\n  return [<EmblaViewportRefType>setViewport, embla]\n}\n\nuseEmblaCarousel.globalOptions = <EmblaOptionsType | undefined>undefined\n\nexport default useEmblaCarousel\n"]},"metadata":{},"sourceType":"module"}