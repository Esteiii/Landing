{"ast":null,"code":"function map(value, iStart, iStop, oStart, oStop) {\n  return oStart + (oStop - oStart) * ((value - iStart) / (iStop - iStart));\n}\n\nfunction isNumber(subject) {\n  return typeof subject === 'number';\n}\n\nfunction isObject(subject) {\n  return Object.prototype.toString.call(subject) === '[object Object]';\n}\n\nfunction isArray(subject) {\n  return Array.isArray(subject);\n}\n\nfunction isRecord(subject) {\n  return isObject(subject) || isArray(subject);\n}\n\nfunction mathAbs(n) {\n  return Math.abs(n);\n}\n\nfunction mathSign(n) {\n  return !n ? 0 : n / mathAbs(n);\n}\n\nfunction deltaAbs(valueB, valueA) {\n  return mathAbs(valueB - valueA);\n}\n\nfunction factorAbs(valueB, valueA) {\n  if (valueB === 0 || valueA === 0) return 0;\n  if (mathAbs(valueB) <= mathAbs(valueA)) return 0;\n  var diff = deltaAbs(mathAbs(valueB), mathAbs(valueA));\n  return mathAbs(diff / valueB);\n}\n\nfunction roundToDecimals(decimalPoints) {\n  var pow = Math.pow(10, decimalPoints);\n  return function (n) {\n    return Math.round(n * pow) / pow;\n  };\n}\n\nfunction arrayKeys(array) {\n  return objectKeys(array).map(Number);\n}\n\nfunction arrayLast(array) {\n  return array[arrayLastIndex(array)];\n}\n\nfunction arrayLastIndex(array) {\n  return Math.max(0, array.length - 1);\n}\n\nfunction objectKeys(object) {\n  return Object.keys(object);\n}\n\nfunction objectsMergeDeep(objectA, objectB) {\n  return [objectA, objectB].reduce(function (mergedObjects, currentObject) {\n    objectKeys(currentObject).forEach(function (key) {\n      var valueA = mergedObjects[key];\n      var valueB = currentObject[key];\n      var areObjects = isObject(valueA) && isObject(valueB);\n      mergedObjects[key] = areObjects ? objectsMergeDeep(valueA, valueB) : valueB;\n    });\n    return mergedObjects;\n  }, {});\n}\n\nfunction objectsAreEqual(objectA, objectB) {\n  var objectAKeys = objectKeys(objectA);\n  var objectBKeys = objectKeys(objectB);\n  if (objectAKeys.length !== objectBKeys.length) return false;\n  return objectAKeys.every(function (key) {\n    var valueA = objectA[key];\n    var valueB = objectB[key];\n    if (typeof valueA === 'function') return \"\".concat(valueA) === \"\".concat(valueB);\n    if (!isRecord(valueA) || !isRecord(valueB)) return valueA === valueB;\n    return objectsAreEqual(valueA, valueB);\n  });\n}\n\nfunction Alignment(align, viewSize) {\n  var predefined = {\n    start: start,\n    center: center,\n    end: end\n  };\n\n  function start() {\n    return 0;\n  }\n\n  function center(n) {\n    return end(n) / 2;\n  }\n\n  function end(n) {\n    return viewSize - n;\n  }\n\n  function percent() {\n    return viewSize * Number(align);\n  }\n\n  function measure(n) {\n    if (isNumber(align)) return percent();\n    return predefined[align](n);\n  }\n\n  var self = {\n    measure: measure\n  };\n  return self;\n}\n\nfunction Animation(callback) {\n  var animationFrame = 0;\n\n  function ifAnimating(active, cb) {\n    return function () {\n      if (active === !!animationFrame) cb();\n    };\n  }\n\n  function start() {\n    animationFrame = window.requestAnimationFrame(callback);\n  }\n\n  function stop() {\n    window.cancelAnimationFrame(animationFrame);\n    animationFrame = 0;\n  }\n\n  var self = {\n    proceed: ifAnimating(true, start),\n    start: ifAnimating(false, start),\n    stop: ifAnimating(true, stop)\n  };\n  return self;\n}\n\nfunction Axis(axis, direction) {\n  var scroll = axis === 'y' ? 'y' : 'x';\n  var cross = axis === 'y' ? 'x' : 'y';\n  var startEdge = getStartEdge();\n  var endEdge = getEndEdge();\n\n  function measureSize(rect) {\n    var width = rect.width,\n        height = rect.height;\n    return scroll === 'x' ? width : height;\n  }\n\n  function getStartEdge() {\n    if (scroll === 'y') return 'top';\n    return direction === 'rtl' ? 'right' : 'left';\n  }\n\n  function getEndEdge() {\n    if (scroll === 'y') return 'bottom';\n    return direction === 'rtl' ? 'left' : 'right';\n  }\n\n  var self = {\n    scroll: scroll,\n    cross: cross,\n    startEdge: startEdge,\n    endEdge: endEdge,\n    measureSize: measureSize\n  };\n  return self;\n}\n\nfunction Limit(min, max) {\n  var length = mathAbs(min - max);\n\n  function reachedMin(n) {\n    return n < min;\n  }\n\n  function reachedMax(n) {\n    return n > max;\n  }\n\n  function reachedAny(n) {\n    return reachedMin(n) || reachedMax(n);\n  }\n\n  function constrain(n) {\n    if (!reachedAny(n)) return n;\n    return reachedMin(n) ? min : max;\n  }\n\n  function removeOffset(n) {\n    if (!length) return n;\n    return n - length * Math.ceil((n - max) / length);\n  }\n\n  var self = {\n    length: length,\n    max: max,\n    min: min,\n    constrain: constrain,\n    reachedAny: reachedAny,\n    reachedMax: reachedMax,\n    reachedMin: reachedMin,\n    removeOffset: removeOffset\n  };\n  return self;\n}\n\nfunction Counter(max, start, loop) {\n  var _a = Limit(0, max),\n      min = _a.min,\n      constrain = _a.constrain;\n\n  var loopEnd = max + 1;\n  var counter = withinLimit(start);\n\n  function withinLimit(n) {\n    return !loop ? constrain(n) : mathAbs((loopEnd + n) % loopEnd);\n  }\n\n  function get() {\n    return counter;\n  }\n\n  function set(n) {\n    counter = withinLimit(n);\n    return self;\n  }\n\n  function add(n) {\n    return set(get() + n);\n  }\n\n  function clone() {\n    return Counter(max, get(), loop);\n  }\n\n  var self = {\n    add: add,\n    clone: clone,\n    get: get,\n    set: set,\n    min: min,\n    max: max\n  };\n  return self;\n}\n\nfunction Direction(direction) {\n  var sign = direction === 'rtl' ? -1 : 1;\n\n  function apply(n) {\n    return n * sign;\n  }\n\n  var self = {\n    apply: apply\n  };\n  return self;\n}\n\nfunction EventStore() {\n  var listeners = [];\n\n  function add(node, type, handler, options) {\n    if (options === void 0) {\n      options = false;\n    }\n\n    node.addEventListener(type, handler, options);\n    listeners.push(function () {\n      return node.removeEventListener(type, handler, options);\n    });\n    return self;\n  }\n\n  function removeAll() {\n    listeners = listeners.filter(function (remove) {\n      return remove();\n    });\n    return self;\n  }\n\n  var self = {\n    add: add,\n    removeAll: removeAll\n  };\n  return self;\n}\n\nfunction Vector1D(value) {\n  var vector = value;\n\n  function get() {\n    return vector;\n  }\n\n  function set(n) {\n    vector = readNumber(n);\n    return self;\n  }\n\n  function add(n) {\n    vector += readNumber(n);\n    return self;\n  }\n\n  function subtract(n) {\n    vector -= readNumber(n);\n    return self;\n  }\n\n  function multiply(n) {\n    vector *= n;\n    return self;\n  }\n\n  function divide(n) {\n    vector /= n;\n    return self;\n  }\n\n  function normalize() {\n    if (vector !== 0) divide(vector);\n    return self;\n  }\n\n  function readNumber(n) {\n    return isNumber(n) ? n : n.get();\n  }\n\n  var self = {\n    add: add,\n    divide: divide,\n    get: get,\n    multiply: multiply,\n    normalize: normalize,\n    set: set,\n    subtract: subtract\n  };\n  return self;\n}\n\nfunction DragHandler(axis, direction, rootNode, target, dragTracker, location, animation, scrollTo, scrollBody, scrollTarget, index, eventHandler, percentOfView, loop, dragFree, skipSnaps) {\n  var crossAxis = axis.cross;\n  var focusNodes = ['INPUT', 'SELECT', 'TEXTAREA'];\n  var dragStartPoint = Vector1D(0);\n  var activationEvents = EventStore();\n  var interactionEvents = EventStore();\n  var dragThreshold = percentOfView.measure(20);\n  var snapForceBoost = {\n    mouse: 300,\n    touch: 400\n  };\n  var freeForceBoost = {\n    mouse: 500,\n    touch: 600\n  };\n  var baseSpeed = dragFree ? 5 : 16;\n  var baseMass = 1;\n  var startScroll = 0;\n  var startCross = 0;\n  var pointerIsDown = false;\n  var preventScroll = false;\n  var preventClick = false;\n  var isMouse = false;\n\n  function addActivationEvents() {\n    var node = rootNode;\n    activationEvents.add(node, 'touchmove', function () {\n      return undefined;\n    }).add(node, 'touchend', function () {\n      return undefined;\n    }).add(node, 'touchstart', down).add(node, 'mousedown', down).add(node, 'touchcancel', up).add(node, 'contextmenu', up).add(node, 'click', click);\n  }\n\n  function addInteractionEvents() {\n    var node = !isMouse ? rootNode : document;\n    interactionEvents.add(node, 'touchmove', move).add(node, 'touchend', up).add(node, 'mousemove', move).add(node, 'mouseup', up);\n  }\n\n  function removeAllEvents() {\n    activationEvents.removeAll();\n    interactionEvents.removeAll();\n  }\n\n  function isFocusNode(node) {\n    var name = node.nodeName || '';\n    return focusNodes.indexOf(name) > -1;\n  }\n\n  function forceBoost() {\n    var boost = dragFree ? freeForceBoost : snapForceBoost;\n    var type = isMouse ? 'mouse' : 'touch';\n    return boost[type];\n  }\n\n  function allowedForce(force, targetChanged) {\n    var next = index.clone().add(mathSign(force) * -1);\n    var isEdge = next.get() === index.min || next.get() === index.max;\n    var baseForce = scrollTarget.byDistance(force, !dragFree).distance;\n    if (dragFree || mathAbs(force) < dragThreshold) return baseForce;\n    if (!loop && isEdge) return baseForce * 0.4;\n    if (skipSnaps && targetChanged) return baseForce * 0.5;\n    return scrollTarget.byIndex(next.get(), 0).distance;\n  }\n\n  function down(evt) {\n    isMouse = evt.type === 'mousedown';\n    if (isMouse && evt.button !== 0) return;\n    var isMoving = deltaAbs(target.get(), location.get()) >= 2;\n    var clearPreventClick = isMouse || !isMoving;\n    var isNotFocusNode = !isFocusNode(evt.target);\n    var preventDefault = isMoving || isMouse && isNotFocusNode;\n    pointerIsDown = true;\n    dragTracker.pointerDown(evt);\n    dragStartPoint.set(target);\n    target.set(location);\n    scrollBody.useBaseMass().useSpeed(80);\n    addInteractionEvents();\n    startScroll = dragTracker.readPoint(evt);\n    startCross = dragTracker.readPoint(evt, crossAxis);\n    eventHandler.emit('pointerDown');\n    if (clearPreventClick) preventClick = false;\n    if (preventDefault) evt.preventDefault();\n  }\n\n  function move(evt) {\n    if (!preventScroll && !isMouse) {\n      if (!evt.cancelable) return up(evt);\n      var lastScroll = dragTracker.readPoint(evt);\n      var lastCross = dragTracker.readPoint(evt, crossAxis);\n      var diffScroll = deltaAbs(lastScroll, startScroll);\n      var diffCross = deltaAbs(lastCross, startCross);\n      preventScroll = diffScroll > diffCross;\n      if (!preventScroll && !preventClick) return up(evt);\n    }\n\n    var diff = dragTracker.pointerMove(evt);\n    if (!preventClick && diff) preventClick = true;\n    animation.start();\n    target.add(direction.apply(diff));\n    evt.preventDefault();\n  }\n\n  function up(evt) {\n    var currentLocation = scrollTarget.byDistance(0, false);\n    var targetChanged = currentLocation.index !== index.get();\n    var rawForce = dragTracker.pointerUp(evt) * forceBoost();\n    var force = allowedForce(direction.apply(rawForce), targetChanged);\n    var forceFactor = factorAbs(rawForce, force);\n    var isMoving = deltaAbs(target.get(), dragStartPoint.get()) >= 0.5;\n    var isVigorous = targetChanged && forceFactor > 0.75;\n    var isBelowThreshold = mathAbs(rawForce) < dragThreshold;\n    var speed = isVigorous ? 10 : baseSpeed;\n    var mass = isVigorous ? baseMass + 2.5 * forceFactor : baseMass;\n    if (isMoving && !isMouse) preventClick = true;\n    preventScroll = false;\n    pointerIsDown = false;\n    interactionEvents.removeAll();\n    scrollBody.useSpeed(isBelowThreshold ? 9 : speed).useMass(mass);\n    scrollTo.distance(force, !dragFree);\n    isMouse = false;\n    eventHandler.emit('pointerUp');\n  }\n\n  function click(evt) {\n    if (preventClick) evt.preventDefault();\n  }\n\n  function clickAllowed() {\n    return !preventClick;\n  }\n\n  function pointerDown() {\n    return pointerIsDown;\n  }\n\n  var self = {\n    addActivationEvents: addActivationEvents,\n    clickAllowed: clickAllowed,\n    pointerDown: pointerDown,\n    removeAllEvents: removeAllEvents\n  };\n  return self;\n}\n\nfunction DragTracker(axis) {\n  var logInterval = 170;\n  var startEvent;\n  var lastEvent;\n\n  function isTouchEvent(evt) {\n    return typeof TouchEvent !== 'undefined' && evt instanceof TouchEvent;\n  }\n\n  function readTime(evt) {\n    return evt.timeStamp;\n  }\n\n  function readPoint(evt, evtAxis) {\n    var property = evtAxis || axis.scroll;\n    var coord = \"client\".concat(property === 'x' ? 'X' : 'Y');\n    return (isTouchEvent(evt) ? evt.touches[0] : evt)[coord];\n  }\n\n  function pointerDown(evt) {\n    startEvent = evt;\n    lastEvent = evt;\n    return readPoint(evt);\n  }\n\n  function pointerMove(evt) {\n    var diff = readPoint(evt) - readPoint(lastEvent);\n    var expired = readTime(evt) - readTime(startEvent) > logInterval;\n    lastEvent = evt;\n    if (expired) startEvent = evt;\n    return diff;\n  }\n\n  function pointerUp(evt) {\n    if (!startEvent || !lastEvent) return 0;\n    var diffDrag = readPoint(lastEvent) - readPoint(startEvent);\n    var diffTime = readTime(evt) - readTime(startEvent);\n    var expired = readTime(evt) - readTime(lastEvent) > logInterval;\n    var force = diffDrag / diffTime;\n    var isFlick = diffTime && !expired && mathAbs(force) > 0.1;\n    return isFlick ? force : 0;\n  }\n\n  var self = {\n    isTouchEvent: isTouchEvent,\n    pointerDown: pointerDown,\n    pointerMove: pointerMove,\n    pointerUp: pointerUp,\n    readPoint: readPoint\n  };\n  return self;\n}\n\nfunction PercentOfView(viewSize) {\n  function measure(n) {\n    return viewSize * (n / 100);\n  }\n\n  var self = {\n    measure: measure\n  };\n  return self;\n}\n\nfunction ScrollBody(location, baseSpeed, baseMass) {\n  var roundToTwoDecimals = roundToDecimals(2);\n  var velocity = Vector1D(0);\n  var acceleration = Vector1D(0);\n  var attraction = Vector1D(0);\n  var attractionDirection = 0;\n  var speed = baseSpeed;\n  var mass = baseMass;\n\n  function update() {\n    velocity.add(acceleration);\n    location.add(velocity);\n    acceleration.multiply(0);\n  }\n\n  function applyForce(force) {\n    force.divide(mass);\n    acceleration.add(force);\n  }\n\n  function seek(target) {\n    attraction.set(target).subtract(location);\n    var magnitude = map(attraction.get(), 0, 100, 0, speed);\n    attractionDirection = mathSign(attraction.get());\n    attraction.normalize().multiply(magnitude).subtract(velocity);\n    applyForce(attraction);\n    return self;\n  }\n\n  function settle(target) {\n    var diff = target.get() - location.get();\n    var hasSettled = !roundToTwoDecimals(diff);\n    if (hasSettled) location.set(target);\n    return hasSettled;\n  }\n\n  function direction() {\n    return attractionDirection;\n  }\n\n  function useBaseSpeed() {\n    return useSpeed(baseSpeed);\n  }\n\n  function useBaseMass() {\n    return useMass(baseMass);\n  }\n\n  function useSpeed(n) {\n    speed = n;\n    return self;\n  }\n\n  function useMass(n) {\n    mass = n;\n    return self;\n  }\n\n  var self = {\n    direction: direction,\n    seek: seek,\n    settle: settle,\n    update: update,\n    useBaseMass: useBaseMass,\n    useBaseSpeed: useBaseSpeed,\n    useMass: useMass,\n    useSpeed: useSpeed\n  };\n  return self;\n}\n\nfunction ScrollBounds(limit, location, target, scrollBody, percentOfView) {\n  var pullBackThreshold = percentOfView.measure(10);\n  var edgeOffsetTolerance = percentOfView.measure(50);\n  var maxFriction = 0.85;\n  var disabled = false;\n\n  function shouldConstrain() {\n    if (disabled) return false;\n    if (!limit.reachedAny(target.get())) return false;\n    if (!limit.reachedAny(location.get())) return false;\n    return true;\n  }\n\n  function constrain(pointerDown) {\n    if (!shouldConstrain()) return;\n    var edge = limit.reachedMin(location.get()) ? 'min' : 'max';\n    var diffToEdge = mathAbs(limit[edge] - location.get());\n    var diffToTarget = target.get() - location.get();\n    var friction = Math.min(diffToEdge / edgeOffsetTolerance, maxFriction);\n    target.subtract(diffToTarget * friction);\n\n    if (!pointerDown && mathAbs(diffToTarget) < pullBackThreshold) {\n      target.set(limit.constrain(target.get()));\n      scrollBody.useSpeed(10).useMass(3);\n    }\n  }\n\n  function toggleActive(active) {\n    disabled = !active;\n  }\n\n  var self = {\n    constrain: constrain,\n    toggleActive: toggleActive\n  };\n  return self;\n}\n\nfunction ScrollContain(viewSize, contentSize, snapsAligned, containScroll) {\n  var scrollBounds = Limit(-contentSize + viewSize, snapsAligned[0]);\n  var snapsBounded = snapsAligned.map(scrollBounds.constrain);\n  var snapsContained = measureContained();\n\n  function findDuplicates() {\n    var startSnap = snapsBounded[0];\n    var endSnap = arrayLast(snapsBounded);\n    var min = snapsBounded.lastIndexOf(startSnap);\n    var max = snapsBounded.indexOf(endSnap) + 1;\n    return Limit(min, max);\n  }\n\n  function measureContained() {\n    if (contentSize <= viewSize) return [scrollBounds.max];\n    if (containScroll === 'keepSnaps') return snapsBounded;\n\n    var _a = findDuplicates(),\n        min = _a.min,\n        max = _a.max;\n\n    return snapsBounded.slice(min, max);\n  }\n\n  var self = {\n    snapsContained: snapsContained\n  };\n  return self;\n}\n\nfunction ScrollLimit(contentSize, scrollSnaps, loop) {\n  var limit = measureLimit();\n\n  function measureLimit() {\n    var startSnap = scrollSnaps[0];\n    var endSnap = arrayLast(scrollSnaps);\n    var min = loop ? startSnap - contentSize : endSnap;\n    var max = startSnap;\n    return Limit(min, max);\n  }\n\n  var self = {\n    limit: limit\n  };\n  return self;\n}\n\nfunction ScrollLooper(contentSize, limit, location, vectors) {\n  var jointSafety = 0.1;\n  var min = limit.min + jointSafety;\n  var max = limit.max + jointSafety;\n\n  var _a = Limit(min, max),\n      reachedMin = _a.reachedMin,\n      reachedMax = _a.reachedMax;\n\n  function shouldLoop(direction) {\n    if (direction === 1) return reachedMax(location.get());\n    if (direction === -1) return reachedMin(location.get());\n    return false;\n  }\n\n  function loop(direction) {\n    if (!shouldLoop(direction)) return;\n    var loopDistance = contentSize * (direction * -1);\n    vectors.forEach(function (v) {\n      return v.add(loopDistance);\n    });\n  }\n\n  var self = {\n    loop: loop\n  };\n  return self;\n}\n\nfunction ScrollProgress(limit) {\n  var max = limit.max,\n      scrollLength = limit.length;\n\n  function get(n) {\n    var currentLocation = n - max;\n    return currentLocation / -scrollLength;\n  }\n\n  var self = {\n    get: get\n  };\n  return self;\n}\n\nfunction ScrollSnaps(axis, alignment, containerRect, slideRects, slideSizesWithGaps, slidesToScroll, containScroll) {\n  var startEdge = axis.startEdge,\n      endEdge = axis.endEdge;\n  var groupSlides = slidesToScroll.groupSlides;\n  var alignments = measureSizes().map(alignment.measure);\n  var snaps = measureUnaligned();\n  var snapsAligned = measureAligned();\n\n  function measureSizes() {\n    return groupSlides(slideRects).map(function (rects) {\n      return arrayLast(rects)[endEdge] - rects[0][startEdge];\n    }).map(mathAbs);\n  }\n\n  function measureUnaligned() {\n    return slideRects.map(function (rect) {\n      return containerRect[startEdge] - rect[startEdge];\n    }).map(function (snap) {\n      return -mathAbs(snap);\n    });\n  }\n\n  function measureAligned() {\n    var containedStartSnap = 0;\n    var containedEndSnap = arrayLast(snaps) - arrayLast(slideSizesWithGaps);\n    return groupSlides(snaps).map(function (g) {\n      return g[0];\n    }).map(function (snap, index, groupedSnaps) {\n      var isFirst = !index;\n      var isLast = index === arrayLastIndex(groupedSnaps);\n      if (containScroll && isFirst) return containedStartSnap;\n      if (containScroll && isLast) return containedEndSnap;\n      return snap + alignments[index];\n    });\n  }\n\n  var self = {\n    snaps: snaps,\n    snapsAligned: snapsAligned\n  };\n  return self;\n}\n\nfunction ScrollTarget(loop, scrollSnaps, contentSize, limit, targetVector) {\n  var reachedAny = limit.reachedAny,\n      removeOffset = limit.removeOffset,\n      constrain = limit.constrain;\n\n  function minDistance(distances) {\n    return distances.concat().sort(function (a, b) {\n      return mathAbs(a) - mathAbs(b);\n    })[0];\n  }\n\n  function findTargetSnap(target) {\n    var distance = loop ? removeOffset(target) : constrain(target);\n    var ascDiffsToSnaps = scrollSnaps.map(function (scrollSnap) {\n      return scrollSnap - distance;\n    }).map(function (diffToSnap) {\n      return shortcut(diffToSnap, 0);\n    }).map(function (diff, i) {\n      return {\n        diff: diff,\n        index: i\n      };\n    }).sort(function (d1, d2) {\n      return mathAbs(d1.diff) - mathAbs(d2.diff);\n    });\n    var index = ascDiffsToSnaps[0].index;\n    return {\n      index: index,\n      distance: distance\n    };\n  }\n\n  function shortcut(target, direction) {\n    var targets = [target, target + contentSize, target - contentSize];\n    if (!loop) return targets[0];\n    if (!direction) return minDistance(targets);\n    var matchingTargets = targets.filter(function (t) {\n      return mathSign(t) === direction;\n    });\n    return minDistance(matchingTargets);\n  }\n\n  function byIndex(index, direction) {\n    var diffToSnap = scrollSnaps[index] - targetVector.get();\n    var distance = shortcut(diffToSnap, direction);\n    return {\n      index: index,\n      distance: distance\n    };\n  }\n\n  function byDistance(distance, snap) {\n    var target = targetVector.get() + distance;\n\n    var _a = findTargetSnap(target),\n        index = _a.index,\n        targetSnapDistance = _a.distance;\n\n    var reachedBound = !loop && reachedAny(target);\n    if (!snap || reachedBound) return {\n      index: index,\n      distance: distance\n    };\n    var diffToSnap = scrollSnaps[index] - targetSnapDistance;\n    var snapDistance = distance + shortcut(diffToSnap, 0);\n    return {\n      index: index,\n      distance: snapDistance\n    };\n  }\n\n  var self = {\n    byDistance: byDistance,\n    byIndex: byIndex,\n    shortcut: shortcut\n  };\n  return self;\n}\n\nfunction ScrollTo(animation, indexCurrent, indexPrevious, scrollTarget, targetVector, eventHandler) {\n  function scrollTo(target) {\n    var distanceDiff = target.distance;\n    var indexDiff = target.index !== indexCurrent.get();\n\n    if (distanceDiff) {\n      animation.start();\n      targetVector.add(distanceDiff);\n    }\n\n    if (indexDiff) {\n      indexPrevious.set(indexCurrent.get());\n      indexCurrent.set(target.index);\n      eventHandler.emit('select');\n    }\n  }\n\n  function distance(n, snap) {\n    var target = scrollTarget.byDistance(n, snap);\n    scrollTo(target);\n  }\n\n  function index(n, direction) {\n    var targetIndex = indexCurrent.clone().set(n);\n    var target = scrollTarget.byIndex(targetIndex.get(), direction);\n    scrollTo(target);\n  }\n\n  var self = {\n    distance: distance,\n    index: index\n  };\n  return self;\n}\n\nfunction Translate(axis, direction, container) {\n  var translate = axis.scroll === 'x' ? x : y;\n  var containerStyle = container.style;\n  var disabled = false;\n\n  function x(n) {\n    return \"translate3d(\".concat(n, \"px,0px,0px)\");\n  }\n\n  function y(n) {\n    return \"translate3d(0px,\".concat(n, \"px,0px)\");\n  }\n\n  function to(target) {\n    if (disabled) return;\n    containerStyle.transform = translate(direction.apply(target.get()));\n  }\n\n  function toggleActive(active) {\n    disabled = !active;\n  }\n\n  function clear() {\n    if (disabled) return;\n    containerStyle.transform = '';\n    if (!container.getAttribute('style')) container.removeAttribute('style');\n  }\n\n  var self = {\n    clear: clear,\n    to: to,\n    toggleActive: toggleActive\n  };\n  return self;\n}\n\nfunction SlideLooper(axis, direction, viewSize, contentSize, slideSizesWithGaps, scrollSnaps, slidesInView, scroll, slides) {\n  var ascItems = arrayKeys(slideSizesWithGaps);\n  var descItems = arrayKeys(slideSizesWithGaps).reverse();\n  var loopPoints = startPoints().concat(endPoints());\n\n  function removeSlideSizes(indexes, from) {\n    return indexes.reduce(function (a, i) {\n      return a - slideSizesWithGaps[i];\n    }, from);\n  }\n\n  function slidesInGap(indexes, gap) {\n    return indexes.reduce(function (a, i) {\n      var remainingGap = removeSlideSizes(a, gap);\n      return remainingGap > 0 ? a.concat([i]) : a;\n    }, []);\n  }\n\n  function findLoopPoints(indexes, edge) {\n    var isStartEdge = edge === 'start';\n    var offset = isStartEdge ? -contentSize : contentSize;\n    var slideBounds = slidesInView.findSlideBounds([offset]);\n    return indexes.map(function (index) {\n      var initial = isStartEdge ? 0 : -contentSize;\n      var altered = isStartEdge ? contentSize : 0;\n      var bounds = slideBounds.filter(function (b) {\n        return b.index === index;\n      })[0];\n      var point = bounds[isStartEdge ? 'end' : 'start'];\n      var shift = Vector1D(-1);\n      var location = Vector1D(-1);\n      var translate = Translate(axis, direction, slides[index]);\n\n      var target = function () {\n        return shift.set(scroll.get() > point ? initial : altered);\n      };\n\n      return {\n        index: index,\n        location: location,\n        translate: translate,\n        target: target\n      };\n    });\n  }\n\n  function startPoints() {\n    var gap = scrollSnaps[0] - 1;\n    var indexes = slidesInGap(descItems, gap);\n    return findLoopPoints(indexes, 'end');\n  }\n\n  function endPoints() {\n    var gap = viewSize - scrollSnaps[0] - 1;\n    var indexes = slidesInGap(ascItems, gap);\n    return findLoopPoints(indexes, 'start');\n  }\n\n  function canLoop() {\n    return loopPoints.every(function (_a) {\n      var index = _a.index;\n      var otherIndexes = ascItems.filter(function (i) {\n        return i !== index;\n      });\n      return removeSlideSizes(otherIndexes, viewSize) <= 0.1;\n    });\n  }\n\n  function loop() {\n    loopPoints.forEach(function (loopPoint) {\n      var target = loopPoint.target,\n          translate = loopPoint.translate,\n          location = loopPoint.location;\n      var shift = target();\n      if (shift.get() === location.get()) return;\n      if (shift.get() === 0) translate.clear();else translate.to(shift);\n      location.set(shift);\n    });\n  }\n\n  function clear() {\n    loopPoints.forEach(function (loopPoint) {\n      return loopPoint.translate.clear();\n    });\n  }\n\n  var self = {\n    canLoop: canLoop,\n    clear: clear,\n    loop: loop,\n    loopPoints: loopPoints\n  };\n  return self;\n}\n\nfunction SlidesInView(viewSize, contentSize, slideSizes, snaps, limit, loop, inViewThreshold) {\n  var removeOffset = limit.removeOffset,\n      constrain = limit.constrain;\n  var roundingSafety = 0.5;\n  var cachedOffsets = loop ? [0, contentSize, -contentSize] : [0];\n  var cachedBounds = findSlideBounds(cachedOffsets, inViewThreshold);\n\n  function findSlideThresholds(threshold) {\n    var slideThreshold = threshold || 0;\n    return slideSizes.map(function (slideSize) {\n      var thresholdLimit = Limit(roundingSafety, slideSize - roundingSafety);\n      return thresholdLimit.constrain(slideSize * slideThreshold);\n    });\n  }\n\n  function findSlideBounds(offsets, threshold) {\n    var slideOffsets = offsets || cachedOffsets;\n    var slideThresholds = findSlideThresholds(threshold);\n    return slideOffsets.reduce(function (list, offset) {\n      var bounds = snaps.map(function (snap, index) {\n        return {\n          start: snap - slideSizes[index] + slideThresholds[index] + offset,\n          end: snap + viewSize - slideThresholds[index] + offset,\n          index: index\n        };\n      });\n      return list.concat(bounds);\n    }, []);\n  }\n\n  function check(location, bounds) {\n    var limitedLocation = loop ? removeOffset(location) : constrain(location);\n    var slideBounds = bounds || cachedBounds;\n    return slideBounds.reduce(function (list, slideBound) {\n      var index = slideBound.index,\n          start = slideBound.start,\n          end = slideBound.end;\n      var inList = list.indexOf(index) !== -1;\n      var inView = start < limitedLocation && end > limitedLocation;\n      return !inList && inView ? list.concat([index]) : list;\n    }, []);\n  }\n\n  var self = {\n    check: check,\n    findSlideBounds: findSlideBounds\n  };\n  return self;\n}\n\nfunction SlideSizes(axis, containerRect, slideRects, slides, includeEdgeGap) {\n  var measureSize = axis.measureSize,\n      startEdge = axis.startEdge,\n      endEdge = axis.endEdge;\n  var startGap = measureStartGap();\n  var endGap = measureEndGap();\n  var slideSizes = slideRects.map(measureSize);\n  var slideSizesWithGaps = measureWithGaps();\n\n  function measureStartGap() {\n    if (!includeEdgeGap) return 0;\n    var slideRect = slideRects[0];\n    return mathAbs(containerRect[startEdge] - slideRect[startEdge]);\n  }\n\n  function measureEndGap() {\n    if (!includeEdgeGap) return 0;\n    var style = window.getComputedStyle(arrayLast(slides));\n    return parseFloat(style.getPropertyValue(\"margin-\".concat(endEdge)));\n  }\n\n  function measureWithGaps() {\n    return slideRects.map(function (rect, index, rects) {\n      var isFirst = !index;\n      var isLast = index === arrayLastIndex(rects);\n      if (isFirst) return slideSizes[index] + startGap;\n      if (isLast) return slideSizes[index] + endGap;\n      return rects[index + 1][startEdge] - rect[startEdge];\n    }).map(mathAbs);\n  }\n\n  var self = {\n    slideSizes: slideSizes,\n    slideSizesWithGaps: slideSizesWithGaps\n  };\n  return self;\n}\n\nfunction SlidesToScroll(viewSize, slideSizesWithGaps, slidesToScroll) {\n  var groupByNumber = isNumber(slidesToScroll);\n\n  function byNumber(array, groupSize) {\n    return arrayKeys(array).filter(function (i) {\n      return i % groupSize === 0;\n    }).map(function (i) {\n      return array.slice(i, i + groupSize);\n    });\n  }\n\n  function bySize(array) {\n    return arrayKeys(array).reduce(function (groupSizes, i) {\n      var chunk = slideSizesWithGaps.slice(arrayLast(groupSizes), i + 1);\n      var chunkSize = chunk.reduce(function (a, s) {\n        return a + s;\n      }, 0);\n      return !i || chunkSize > viewSize ? groupSizes.concat(i) : groupSizes;\n    }, []).map(function (start, i, groupSizes) {\n      return array.slice(start, groupSizes[i + 1]);\n    });\n  }\n\n  function groupSlides(array) {\n    return groupByNumber ? byNumber(array, slidesToScroll) : bySize(array);\n  }\n\n  var self = {\n    groupSlides: groupSlides\n  };\n  return self;\n}\n\nfunction Engine(root, container, slides, options, eventHandler) {\n  // Options\n  var align = options.align,\n      scrollAxis = options.axis,\n      contentDirection = options.direction,\n      startIndex = options.startIndex,\n      inViewThreshold = options.inViewThreshold,\n      loop = options.loop,\n      speed = options.speed,\n      dragFree = options.dragFree,\n      groupSlides = options.slidesToScroll,\n      skipSnaps = options.skipSnaps,\n      containScroll = options.containScroll; // Measurements\n\n  var containerRect = container.getBoundingClientRect();\n  var slideRects = slides.map(function (slide) {\n    return slide.getBoundingClientRect();\n  });\n  var direction = Direction(contentDirection);\n  var axis = Axis(scrollAxis, contentDirection);\n  var viewSize = axis.measureSize(containerRect);\n  var percentOfView = PercentOfView(viewSize);\n  var alignment = Alignment(align, viewSize);\n  var containSnaps = !loop && containScroll !== '';\n  var includeEdgeGap = loop || containScroll !== '';\n\n  var _a = SlideSizes(axis, containerRect, slideRects, slides, includeEdgeGap),\n      slideSizes = _a.slideSizes,\n      slideSizesWithGaps = _a.slideSizesWithGaps;\n\n  var slidesToScroll = SlidesToScroll(viewSize, slideSizesWithGaps, groupSlides);\n\n  var _b = ScrollSnaps(axis, alignment, containerRect, slideRects, slideSizesWithGaps, slidesToScroll, containSnaps),\n      snaps = _b.snaps,\n      snapsAligned = _b.snapsAligned;\n\n  var contentSize = -arrayLast(snaps) + arrayLast(slideSizesWithGaps);\n  var snapsContained = ScrollContain(viewSize, contentSize, snapsAligned, containScroll).snapsContained;\n  var scrollSnaps = containSnaps ? snapsContained : snapsAligned;\n  var limit = ScrollLimit(contentSize, scrollSnaps, loop).limit; // Indexes\n\n  var index = Counter(arrayLastIndex(scrollSnaps), startIndex, loop);\n  var indexPrevious = index.clone();\n  var slideIndexes = arrayKeys(slides); // Draw\n\n  var update = function () {\n    if (!loop) engine.scrollBounds.constrain(engine.dragHandler.pointerDown());\n    engine.scrollBody.seek(target).update();\n    var settled = engine.scrollBody.settle(target);\n\n    if (settled && !engine.dragHandler.pointerDown()) {\n      engine.animation.stop();\n      eventHandler.emit('settle');\n    }\n\n    if (!settled) {\n      eventHandler.emit('scroll');\n    }\n\n    if (loop) {\n      engine.scrollLooper.loop(engine.scrollBody.direction());\n      engine.slideLooper.loop();\n    }\n\n    engine.translate.to(location);\n    engine.animation.proceed();\n  }; // Shared\n\n\n  var animation = Animation(update);\n  var startLocation = scrollSnaps[index.get()];\n  var location = Vector1D(startLocation);\n  var target = Vector1D(startLocation);\n  var scrollBody = ScrollBody(location, speed, 1);\n  var scrollTarget = ScrollTarget(loop, scrollSnaps, contentSize, limit, target);\n  var scrollTo = ScrollTo(animation, index, indexPrevious, scrollTarget, target, eventHandler);\n  var slidesInView = SlidesInView(viewSize, contentSize, slideSizes, snaps, limit, loop, inViewThreshold); // DragHandler\n\n  var dragHandler = DragHandler(axis, direction, root, target, DragTracker(axis), location, animation, scrollTo, scrollBody, scrollTarget, index, eventHandler, percentOfView, loop, dragFree, skipSnaps); // Engine\n\n  var engine = {\n    containerRect: containerRect,\n    slideRects: slideRects,\n    animation: animation,\n    axis: axis,\n    direction: direction,\n    dragHandler: dragHandler,\n    eventStore: EventStore(),\n    percentOfView: percentOfView,\n    index: index,\n    indexPrevious: indexPrevious,\n    limit: limit,\n    location: location,\n    options: options,\n    scrollBody: scrollBody,\n    scrollBounds: ScrollBounds(limit, location, target, scrollBody, percentOfView),\n    scrollLooper: ScrollLooper(contentSize, limit, location, [location, target]),\n    scrollProgress: ScrollProgress(limit),\n    scrollSnaps: scrollSnaps,\n    scrollTarget: scrollTarget,\n    scrollTo: scrollTo,\n    slideLooper: SlideLooper(axis, direction, viewSize, contentSize, slideSizesWithGaps, scrollSnaps, slidesInView, location, slides),\n    slidesToScroll: slidesToScroll,\n    slidesInView: slidesInView,\n    slideIndexes: slideIndexes,\n    target: target,\n    translate: Translate(axis, direction, container)\n  };\n  return engine;\n}\n\nfunction EventHandler() {\n  var listeners = {};\n\n  function getListeners(evt) {\n    return listeners[evt] || [];\n  }\n\n  function emit(evt) {\n    getListeners(evt).forEach(function (e) {\n      return e(evt);\n    });\n    return self;\n  }\n\n  function on(evt, cb) {\n    listeners[evt] = getListeners(evt).concat([cb]);\n    return self;\n  }\n\n  function off(evt, cb) {\n    listeners[evt] = getListeners(evt).filter(function (e) {\n      return e !== cb;\n    });\n    return self;\n  }\n\n  var self = {\n    emit: emit,\n    off: off,\n    on: on\n  };\n  return self;\n}\n\nvar defaultOptions = {\n  align: 'center',\n  axis: 'x',\n  containScroll: '',\n  direction: 'ltr',\n  slidesToScroll: 1,\n  breakpoints: {},\n  dragFree: false,\n  draggable: true,\n  inViewThreshold: 0,\n  loop: false,\n  skipSnaps: false,\n  speed: 10,\n  startIndex: 0,\n  active: true\n};\n\nfunction OptionsHandler() {\n  function merge(optionsA, optionsB) {\n    return objectsMergeDeep(optionsA, optionsB || {});\n  }\n\n  function areEqual(optionsA, optionsB) {\n    var breakpointsA = JSON.stringify(objectKeys(optionsA.breakpoints || {}));\n    var breakpointsB = JSON.stringify(objectKeys(optionsB.breakpoints || {}));\n    if (breakpointsA !== breakpointsB) return false;\n    return objectsAreEqual(optionsA, optionsB);\n  }\n\n  function atMedia(options) {\n    var optionsAtMedia = options.breakpoints || {};\n    var matchedMediaOptions = objectKeys(optionsAtMedia).filter(function (media) {\n      return window.matchMedia(media).matches;\n    }).map(function (media) {\n      return optionsAtMedia[media];\n    }).reduce(function (a, mediaOption) {\n      return merge(a, mediaOption);\n    }, {});\n    return merge(options, matchedMediaOptions);\n  }\n\n  var self = {\n    merge: merge,\n    areEqual: areEqual,\n    atMedia: atMedia\n  };\n  return self;\n}\n\nfunction PluginsHandler() {\n  var _a = OptionsHandler(),\n      atMedia = _a.atMedia,\n      areEqual = _a.areEqual;\n\n  var activePlugins = [];\n  var pluginsChanged = [];\n\n  function haveChanged() {\n    return pluginsChanged.some(function (hasChanged) {\n      return hasChanged();\n    });\n  }\n\n  function hasChanged(plugin) {\n    var options = atMedia(plugin.options);\n    return function () {\n      return !areEqual(options, atMedia(plugin.options));\n    };\n  }\n\n  function init(plugins, embla) {\n    pluginsChanged = plugins.map(hasChanged);\n    activePlugins = plugins.filter(function (plugin) {\n      return atMedia(plugin.options).active;\n    });\n    activePlugins.forEach(function (plugin) {\n      return plugin.init(embla);\n    });\n    return plugins.reduce(function (map, plugin) {\n      var _a;\n\n      return Object.assign(map, (_a = {}, _a[plugin.name] = plugin, _a));\n    }, {});\n  }\n\n  function destroy() {\n    activePlugins = activePlugins.filter(function (plugin) {\n      return plugin.destroy();\n    });\n  }\n\n  var self = {\n    init: init,\n    destroy: destroy,\n    haveChanged: haveChanged\n  };\n  return self;\n}\n\nfunction EmblaCarousel(nodes, userOptions, userPlugins) {\n  var resizeHandlers = EventStore();\n  var optionsHandler = OptionsHandler();\n  var pluginsHandler = PluginsHandler();\n  var eventHandler = EventHandler();\n  var on = eventHandler.on,\n      off = eventHandler.off;\n  var reInit = reActivate;\n  var destroyed = false;\n  var engine;\n  var optionsBase = optionsHandler.merge(defaultOptions, EmblaCarousel.globalOptions);\n  var options = optionsHandler.merge(optionsBase);\n  var pluginList = [];\n  var pluginApis;\n  var rootSize = 0;\n  var root;\n  var container;\n  var slides;\n\n  function storeElements() {\n    var providedContainer = 'container' in nodes && nodes.container;\n    var providedSlides = 'slides' in nodes && nodes.slides;\n    root = 'root' in nodes ? nodes.root : nodes;\n    container = providedContainer || root.children[0];\n    slides = providedSlides || [].slice.call(container.children);\n  }\n\n  function activate(withOptions, withPlugins) {\n    if (destroyed) return;\n    storeElements();\n    optionsBase = optionsHandler.merge(optionsBase, withOptions);\n    options = optionsHandler.atMedia(optionsBase);\n    engine = Engine(root, container, slides, options, eventHandler);\n    rootSize = engine.axis.measureSize(root.getBoundingClientRect());\n    if (!options.active) return deActivate();\n    engine.translate.to(engine.location);\n    pluginList = withPlugins || pluginList;\n    pluginApis = pluginsHandler.init(pluginList, self);\n\n    if (options.loop) {\n      if (!engine.slideLooper.canLoop()) {\n        deActivate();\n        return activate({\n          loop: false\n        }, withPlugins);\n      }\n\n      engine.slideLooper.loop();\n    }\n\n    if (options.draggable && container.offsetParent && slides.length) {\n      engine.dragHandler.addActivationEvents();\n    }\n  }\n\n  function reActivate(withOptions, withPlugins) {\n    var startIndex = selectedScrollSnap();\n    deActivate();\n    activate(optionsHandler.merge({\n      startIndex: startIndex\n    }, withOptions), withPlugins);\n    eventHandler.emit('reInit');\n  }\n\n  function deActivate() {\n    engine.dragHandler.removeAllEvents();\n    engine.animation.stop();\n    engine.eventStore.removeAll();\n    engine.translate.clear();\n    engine.slideLooper.clear();\n    pluginsHandler.destroy();\n  }\n\n  function destroy() {\n    if (destroyed) return;\n    destroyed = true;\n    resizeHandlers.removeAll();\n    deActivate();\n    eventHandler.emit('destroy');\n  }\n\n  function resize() {\n    var newOptions = optionsHandler.atMedia(optionsBase);\n    var optionsChanged = !optionsHandler.areEqual(newOptions, options);\n    var newRootSize = engine.axis.measureSize(root.getBoundingClientRect());\n    var rootSizeChanged = rootSize !== newRootSize;\n    var pluginsChanged = pluginsHandler.haveChanged();\n    if (rootSizeChanged || optionsChanged || pluginsChanged) reActivate();\n    eventHandler.emit('resize');\n  }\n\n  function slidesInView(target) {\n    var location = engine[target ? 'target' : 'location'].get();\n    var type = options.loop ? 'removeOffset' : 'constrain';\n    return engine.slidesInView.check(engine.limit[type](location));\n  }\n\n  function slidesNotInView(target) {\n    var inView = slidesInView(target);\n    return engine.slideIndexes.filter(function (index) {\n      return inView.indexOf(index) === -1;\n    });\n  }\n\n  function scrollTo(index, jump, direction) {\n    if (!options.active || destroyed) return;\n    engine.scrollBody.useBaseMass().useSpeed(jump ? 100 : options.speed);\n    engine.scrollTo.index(index, direction || 0);\n  }\n\n  function scrollNext(jump) {\n    var next = engine.index.clone().add(1);\n    scrollTo(next.get(), jump === true, -1);\n  }\n\n  function scrollPrev(jump) {\n    var prev = engine.index.clone().add(-1);\n    scrollTo(prev.get(), jump === true, 1);\n  }\n\n  function canScrollNext() {\n    var next = engine.index.clone().add(1);\n    return next.get() !== selectedScrollSnap();\n  }\n\n  function canScrollPrev() {\n    var prev = engine.index.clone().add(-1);\n    return prev.get() !== selectedScrollSnap();\n  }\n\n  function scrollSnapList() {\n    return engine.scrollSnaps.map(engine.scrollProgress.get);\n  }\n\n  function scrollProgress() {\n    return engine.scrollProgress.get(engine.location.get());\n  }\n\n  function selectedScrollSnap() {\n    return engine.index.get();\n  }\n\n  function previousScrollSnap() {\n    return engine.indexPrevious.get();\n  }\n\n  function clickAllowed() {\n    return engine.dragHandler.clickAllowed();\n  }\n\n  function plugins() {\n    return pluginApis;\n  }\n\n  function internalEngine() {\n    return engine;\n  }\n\n  function rootNode() {\n    return root;\n  }\n\n  function containerNode() {\n    return container;\n  }\n\n  function slideNodes() {\n    return slides;\n  }\n\n  var self = {\n    canScrollNext: canScrollNext,\n    canScrollPrev: canScrollPrev,\n    clickAllowed: clickAllowed,\n    containerNode: containerNode,\n    internalEngine: internalEngine,\n    destroy: destroy,\n    off: off,\n    on: on,\n    plugins: plugins,\n    previousScrollSnap: previousScrollSnap,\n    reInit: reInit,\n    rootNode: rootNode,\n    scrollNext: scrollNext,\n    scrollPrev: scrollPrev,\n    scrollProgress: scrollProgress,\n    scrollSnapList: scrollSnapList,\n    scrollTo: scrollTo,\n    selectedScrollSnap: selectedScrollSnap,\n    slideNodes: slideNodes,\n    slidesInView: slidesInView,\n    slidesNotInView: slidesNotInView\n  };\n  activate(userOptions, userPlugins);\n  resizeHandlers.add(window, 'resize', resize);\n  setTimeout(function () {\n    return eventHandler.emit('init');\n  }, 0);\n  return self;\n}\n\nEmblaCarousel.globalOptions = undefined;\nEmblaCarousel.optionsHandler = OptionsHandler;\nexport { EmblaCarousel as default };","map":{"version":3,"sources":["src/components/utils.ts","src/components/Alignment.ts","src/components/Animation.ts","src/components/Axis.ts","src/components/Limit.ts","src/components/Counter.ts","src/components/Direction.ts","src/components/EventStore.ts","src/components/Vector1d.ts","src/components/DragHandler.ts","src/components/DragTracker.ts","src/components/PercentOfView.ts","src/components/ScrollBody.ts","src/components/ScrollBounds.ts","src/components/ScrollContain.ts","src/components/ScrollLimit.ts","src/components/ScrollLooper.ts","src/components/ScrollProgress.ts","src/components/ScrollSnaps.ts","src/components/ScrollTarget.ts","src/components/ScrollTo.ts","src/components/Translate.ts","src/components/SlideLooper.ts","src/components/SlidesInView.ts","src/components/SlideSizes.ts","src/components/SlidesToScroll.ts","src/components/Engine.ts","src/components/EventHandler.ts","src/components/Options.ts","src/components/OptionsHandler.ts","src/components/PluginsHandler.ts","src/components/index.ts"],"names":["oStart","oStop","value","iStop","Object","Array","isObject","isArray","Math","n","mathAbs","valueB","valueA","diff","deltaAbs","pow","objectKeys","array","arrayLastIndex","mergedObjects","currentObject","areObjects","objectsMergeDeep","objectAKeys","objectBKeys","objectA","objectB","isRecord","objectsAreEqual","predefined","start","center","end","viewSize","Number","isNumber","percent","self","measure","animationFrame","active","cb","window","proceed","ifAnimating","stop","scroll","axis","cross","startEdge","getStartEdge","endEdge","getEndEdge","height","rect","direction","measureSize","length","min","reachedMin","reachedMax","reachedAny","max","constrain","removeOffset","Counter","loop","loopEnd","counter","withinLimit","set","get","add","clone","sign","apply","EventStore","listeners","node","removeAll","vector","readNumber","divide","multiply","normalize","subtract","crossAxis","focusNodes","dragStartPoint","Vector1D","activationEvents","interactionEvents","dragThreshold","percentOfView","snapForceBoost","mouse","touch","freeForceBoost","baseSpeed","dragFree","baseMass","startScroll","startCross","pointerIsDown","preventScroll","preventClick","isMouse","name","boost","type","next","index","mathSign","isEdge","baseForce","scrollTarget","skipSnaps","evt","isMoving","target","location","clearPreventClick","isNotFocusNode","isFocusNode","preventDefault","dragTracker","scrollBody","addInteractionEvents","eventHandler","up","lastScroll","lastCross","diffScroll","diffCross","animation","currentLocation","targetChanged","rawForce","forceBoost","force","allowedForce","forceFactor","factorAbs","isVigorous","isBelowThreshold","speed","mass","scrollTo","addActivationEvents","clickAllowed","pointerDown","removeAllEvents","logInterval","property","evtAxis","coord","concat","isTouchEvent","startEvent","lastEvent","readPoint","expired","readTime","diffDrag","diffTime","isFlick","pointerMove","pointerUp","ScrollBody","roundToTwoDecimals","roundToDecimals","velocity","acceleration","attraction","attractionDirection","magnitude","map","applyForce","hasSettled","useSpeed","useMass","seek","settle","update","useBaseMass","useBaseSpeed","pullBackThreshold","edgeOffsetTolerance","maxFriction","disabled","limit","shouldConstrain","edge","diffToEdge","diffToTarget","friction","toggleActive","scrollBounds","Limit","snapsAligned","snapsBounded","snapsContained","measureContained","startSnap","endSnap","arrayLast","contentSize","containScroll","findDuplicates","ScrollLimit","scrollSnaps","measureLimit","jointSafety","shouldLoop","loopDistance","vectors","scrollLength","slidesToScroll","alignments","measureSizes","alignment","snaps","measureUnaligned","measureAligned","rects","containedStartSnap","containedEndSnap","isFirst","isLast","snap","distance","ascDiffsToSnaps","i","d1","d2","targets","minDistance","matchingTargets","diffToSnap","targetVector","shortcut","targetSnapDistance","findTargetSnap","reachedBound","snapDistance","byDistance","byIndex","distanceDiff","indexDiff","indexCurrent","indexPrevious","targetIndex","Translate","container","translate","containerStyle","clear","to","SlideLooper","slideSizesWithGaps","slidesInView","slides","ascItems","arrayKeys","descItems","loopPoints","startPoints","endPoints","a","remainingGap","removeSlideSizes","isStartEdge","offset","slideBounds","initial","altered","bounds","point","shift","gap","indexes","slidesInGap","findLoopPoints","otherIndexes","loopPoint","canLoop","roundingSafety","cachedOffsets","cachedBounds","findSlideBounds","slideThreshold","threshold","thresholdLimit","slideSize","slideOffsets","offsets","slideThresholds","findSlideThresholds","slideSizes","list","limitedLocation","slideBound","inList","inView","check","startGap","measureStartGap","endGap","measureEndGap","slideRects","measureWithGaps","slideRect","containerRect","style","parseFloat","SlidesToScroll","groupByNumber","chunk","chunkSize","groupSizes","byNumber","bySize","groupSlides","scrollAxis","contentDirection","startIndex","inViewThreshold","options","Direction","Axis","PercentOfView","Alignment","containSnaps","includeEdgeGap","SlideSizes","ScrollSnaps","ScrollContain","slideIndexes","engine","settled","Animation","startLocation","ScrollTarget","ScrollTo","SlidesInView","dragHandler","DragHandler","DragTracker","eventStore","ScrollBounds","scrollLooper","ScrollLooper","scrollProgress","ScrollProgress","slideLooper","EventHandler","getListeners","emit","off","on","defaultOptions","align","breakpoints","draggable","OptionsHandler","optionsB","breakpointsA","JSON","optionsA","breakpointsB","optionsAtMedia","matchedMediaOptions","merge","areEqual","atMedia","PluginsHandler","activePlugins","pluginsChanged","plugin","plugins","_a","init","destroy","haveChanged","resizeHandlers","optionsHandler","pluginsHandler","reInit","destroyed","optionsBase","EmblaCarousel","pluginList","rootSize","providedContainer","nodes","providedSlides","root","storeElements","Engine","deActivate","withPlugins","pluginApis","activate","selectedScrollSnap","newOptions","optionsChanged","newRootSize","rootSizeChanged","reActivate","jump","prev","canScrollNext","canScrollPrev","containerNode","internalEngine","previousScrollSnap","rootNode","scrollNext","scrollPrev","scrollSnapList","slideNodes","slidesNotInView","setTimeout"],"mappings":"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","sourcesContent":["export function map(\n  value: number,\n  iStart: number,\n  iStop: number,\n  oStart: number,\n  oStop: number,\n): number {\n  return oStart + (oStop - oStart) * ((value - iStart) / (iStop - iStart))\n}\n\nexport function isNumber(subject: unknown): subject is number {\n  return typeof subject === 'number'\n}\n\nexport function isObject(subject: unknown): subject is Record<string, unknown> {\n  return Object.prototype.toString.call(subject) === '[object Object]'\n}\n\nexport function isArray(subject: unknown): subject is Record<number, unknown> {\n  return Array.isArray(subject)\n}\n\nexport function isRecord(\n  subject: unknown,\n): subject is Record<string | number, unknown> {\n  return isObject(subject) || isArray(subject)\n}\n\nexport function mathAbs(n: number): number {\n  return Math.abs(n)\n}\n\nexport function mathSign(n: number): number {\n  return !n ? 0 : n / mathAbs(n)\n}\n\nexport function deltaAbs(valueB: number, valueA: number): number {\n  return mathAbs(valueB - valueA)\n}\n\nexport function factorAbs(valueB: number, valueA: number): number {\n  if (valueB === 0 || valueA === 0) return 0\n  if (mathAbs(valueB) <= mathAbs(valueA)) return 0\n  const diff = deltaAbs(mathAbs(valueB), mathAbs(valueA))\n  return mathAbs(diff / valueB)\n}\n\nexport function roundToDecimals(decimalPoints: number): (n: number) => number {\n  const pow = Math.pow(10, decimalPoints)\n  return (n: number): number => Math.round(n * pow) / pow\n}\n\nexport function arrayKeys<Type>(array: Type[]): number[] {\n  return objectKeys(array).map(Number)\n}\n\nexport function arrayLast<Type>(array: Type[]): Type {\n  return array[arrayLastIndex(array)]\n}\n\nexport function arrayLastIndex<Type>(array: Type[]): number {\n  return Math.max(0, array.length - 1)\n}\n\nexport function objectKeys<Type>(object: Type): string[] {\n  return Object.keys(object)\n}\n\nexport function objectsMergeDeep(\n  objectA: Record<string, unknown>,\n  objectB: Record<string, unknown>,\n): Record<string, unknown> {\n  return [objectA, objectB].reduce((mergedObjects, currentObject) => {\n    objectKeys(currentObject).forEach((key) => {\n      const valueA = mergedObjects[key]\n      const valueB = currentObject[key]\n      const areObjects = isObject(valueA) && isObject(valueB)\n\n      mergedObjects[key] = areObjects\n        ? objectsMergeDeep(valueA, valueB)\n        : valueB\n    })\n    return mergedObjects\n  }, {})\n}\n\nexport function objectsAreEqual(\n  objectA: Record<string, unknown>,\n  objectB: Record<string, unknown>,\n): boolean {\n  const objectAKeys = objectKeys(objectA)\n  const objectBKeys = objectKeys(objectB)\n\n  if (objectAKeys.length !== objectBKeys.length) return false\n\n  return objectAKeys.every((key) => {\n    const valueA = objectA[key]\n    const valueB = objectB[key]\n    if (typeof valueA === 'function') return `${valueA}` === `${valueB}`\n    if (!isRecord(valueA) || !isRecord(valueB)) return valueA === valueB\n    return objectsAreEqual(valueA, valueB)\n  })\n}\n","import { isNumber } from './utils'\n\nexport type AlignmentOptionType = 'start' | 'center' | 'end' | number\n\nexport type AlignmentType = {\n  measure: (n: number) => number\n}\n\nexport function Alignment(\n  align: AlignmentOptionType,\n  viewSize: number,\n): AlignmentType {\n  const predefined = { start, center, end }\n\n  function start(): number {\n    return 0\n  }\n\n  function center(n: number): number {\n    return end(n) / 2\n  }\n\n  function end(n: number): number {\n    return viewSize - n\n  }\n\n  function percent(): number {\n    return viewSize * Number(align)\n  }\n\n  function measure(n: number): number {\n    if (isNumber(align)) return percent()\n    return predefined[align](n)\n  }\n\n  const self: AlignmentType = {\n    measure,\n  }\n  return self\n}\n","type CallbackType = () => void\n\nexport type AnimationType = {\n  start: () => void\n  stop: () => void\n  proceed: () => void\n}\n\nexport function Animation(callback: FrameRequestCallback): AnimationType {\n  let animationFrame = 0\n\n  function ifAnimating(active: boolean, cb: CallbackType): CallbackType {\n    return (): void => {\n      if (active === !!animationFrame) cb()\n    }\n  }\n\n  function start(): void {\n    animationFrame = window.requestAnimationFrame(callback)\n  }\n\n  function stop(): void {\n    window.cancelAnimationFrame(animationFrame)\n    animationFrame = 0\n  }\n\n  const self: AnimationType = {\n    proceed: ifAnimating(true, start),\n    start: ifAnimating(false, start),\n    stop: ifAnimating(true, stop),\n  }\n  return self\n}\n","import { DirectionOptionType } from './Direction'\n\nexport type AxisOptionType = 'x' | 'y'\ntype AxisEdgeType = 'top' | 'right' | 'bottom' | 'left'\n\nexport type AxisType = {\n  scroll: AxisOptionType\n  cross: AxisOptionType\n  startEdge: AxisEdgeType\n  endEdge: AxisEdgeType\n  measureSize: (rect: DOMRect) => number\n}\n\nexport function Axis(\n  axis: AxisOptionType,\n  direction: DirectionOptionType,\n): AxisType {\n  const scroll = axis === 'y' ? 'y' : 'x'\n  const cross = axis === 'y' ? 'x' : 'y'\n  const startEdge = getStartEdge()\n  const endEdge = getEndEdge()\n\n  function measureSize(rect: DOMRect): number {\n    const { width, height } = rect\n    return scroll === 'x' ? width : height\n  }\n\n  function getStartEdge(): AxisEdgeType {\n    if (scroll === 'y') return 'top'\n    return direction === 'rtl' ? 'right' : 'left'\n  }\n\n  function getEndEdge(): AxisEdgeType {\n    if (scroll === 'y') return 'bottom'\n    return direction === 'rtl' ? 'left' : 'right'\n  }\n\n  const self: AxisType = {\n    scroll,\n    cross,\n    startEdge,\n    endEdge,\n    measureSize,\n  }\n  return self\n}\n","import { mathAbs } from './utils'\n\nexport type LimitType = {\n  min: number\n  max: number\n  length: number\n  constrain: (n: number) => number\n  reachedAny: (n: number) => boolean\n  reachedMax: (n: number) => boolean\n  reachedMin: (n: number) => boolean\n  removeOffset: (n: number) => number\n}\n\nexport function Limit(min: number, max: number): LimitType {\n  const length = mathAbs(min - max)\n\n  function reachedMin(n: number): boolean {\n    return n < min\n  }\n\n  function reachedMax(n: number): boolean {\n    return n > max\n  }\n\n  function reachedAny(n: number): boolean {\n    return reachedMin(n) || reachedMax(n)\n  }\n\n  function constrain(n: number): number {\n    if (!reachedAny(n)) return n\n    return reachedMin(n) ? min : max\n  }\n\n  function removeOffset(n: number): number {\n    if (!length) return n\n    return n - length * Math.ceil((n - max) / length)\n  }\n\n  const self: LimitType = {\n    length,\n    max,\n    min,\n    constrain,\n    reachedAny,\n    reachedMax,\n    reachedMin,\n    removeOffset,\n  }\n  return self\n}\n","import { Limit } from './Limit'\nimport { mathAbs } from './utils'\n\nexport type CounterType = {\n  get: () => number\n  set: (n: number) => CounterType\n  add: (n: number) => CounterType\n  clone: () => CounterType\n  min: number\n  max: number\n}\n\nexport function Counter(\n  max: number,\n  start: number,\n  loop: boolean,\n): CounterType {\n  const { min, constrain } = Limit(0, max)\n  const loopEnd = max + 1\n  let counter = withinLimit(start)\n\n  function withinLimit(n: number): number {\n    return !loop ? constrain(n) : mathAbs((loopEnd + n) % loopEnd)\n  }\n\n  function get(): number {\n    return counter\n  }\n\n  function set(n: number): CounterType {\n    counter = withinLimit(n)\n    return self\n  }\n\n  function add(n: number): CounterType {\n    return set(get() + n)\n  }\n\n  function clone(): CounterType {\n    return Counter(max, get(), loop)\n  }\n\n  const self: CounterType = {\n    add,\n    clone,\n    get,\n    set,\n    min,\n    max,\n  }\n  return self\n}\n","export type DirectionOptionType = 'ltr' | 'rtl'\n\nexport type DirectionType = {\n  apply: (n: number) => number\n}\n\nexport function Direction(direction: DirectionOptionType): DirectionType {\n  const sign = direction === 'rtl' ? -1 : 1\n\n  function apply(n: number): number {\n    return n * sign\n  }\n\n  const self: DirectionType = {\n    apply,\n  }\n  return self\n}\n","type EventNameType = keyof DocumentEventMap | keyof WindowEventMap\ntype EventHandlerType = (evt: any) => void\ntype EventOptionsType = boolean | AddEventListenerOptions | undefined\ntype EventRemoverType = () => void\n\nexport type EventStoreType = {\n  add: (\n    node: EventTarget,\n    type: EventNameType,\n    handler: EventHandlerType,\n    options?: EventOptionsType,\n  ) => EventStoreType\n  removeAll: () => EventStoreType\n}\n\nexport function EventStore(): EventStoreType {\n  let listeners: EventRemoverType[] = []\n\n  function add(\n    node: EventTarget,\n    type: EventNameType,\n    handler: EventHandlerType,\n    options: EventOptionsType = false,\n  ): EventStoreType {\n    node.addEventListener(type, handler, options)\n    listeners.push(() => node.removeEventListener(type, handler, options))\n    return self\n  }\n\n  function removeAll(): EventStoreType {\n    listeners = listeners.filter((remove) => remove())\n    return self\n  }\n\n  const self: EventStoreType = {\n    add,\n    removeAll,\n  }\n  return self\n}\n","import { isNumber } from './utils'\n\nexport type Vector1DType = {\n  get: () => number\n  set: (v: Vector1DType | number) => Vector1DType\n  add: (v: Vector1DType | number) => Vector1DType\n  subtract: (v: Vector1DType | number) => Vector1DType\n  multiply: (n: number) => Vector1DType\n  divide: (n: number) => Vector1DType\n  normalize: () => Vector1DType\n}\n\nexport function Vector1D(value: number): Vector1DType {\n  let vector = value\n\n  function get(): number {\n    return vector\n  }\n\n  function set(n: Vector1DType | number): Vector1DType {\n    vector = readNumber(n)\n    return self\n  }\n\n  function add(n: Vector1DType | number): Vector1DType {\n    vector += readNumber(n)\n    return self\n  }\n\n  function subtract(n: Vector1DType | number): Vector1DType {\n    vector -= readNumber(n)\n    return self\n  }\n\n  function multiply(n: number): Vector1DType {\n    vector *= n\n    return self\n  }\n\n  function divide(n: number): Vector1DType {\n    vector /= n\n    return self\n  }\n\n  function normalize(): Vector1DType {\n    if (vector !== 0) divide(vector)\n    return self\n  }\n\n  function readNumber(n: Vector1DType | number): number {\n    return isNumber(n) ? n : n.get()\n  }\n\n  const self: Vector1DType = {\n    add,\n    divide,\n    get,\n    multiply,\n    normalize,\n    set,\n    subtract,\n  }\n  return self\n}\n","import { AnimationType } from './Animation'\nimport { CounterType } from './Counter'\nimport { DirectionType } from './Direction'\nimport { DragTrackerType, PointerEventType } from './DragTracker'\nimport { EventHandlerType } from './EventHandler'\nimport { AxisType } from './Axis'\nimport { EventStore } from './EventStore'\nimport { ScrollBodyType } from './ScrollBody'\nimport { ScrollTargetType } from './ScrollTarget'\nimport { ScrollToType } from './ScrollTo'\nimport { Vector1D, Vector1DType } from './Vector1d'\nimport { deltaAbs, factorAbs, mathAbs, mathSign } from './utils'\nimport { PercentOfViewType } from './PercentOfView'\n\nexport type DragHandlerType = {\n  addActivationEvents: () => void\n  clickAllowed: () => boolean\n  pointerDown: () => boolean\n  removeAllEvents: () => void\n}\n\nexport function DragHandler(\n  axis: AxisType,\n  direction: DirectionType,\n  rootNode: HTMLElement,\n  target: Vector1DType,\n  dragTracker: DragTrackerType,\n  location: Vector1DType,\n  animation: AnimationType,\n  scrollTo: ScrollToType,\n  scrollBody: ScrollBodyType,\n  scrollTarget: ScrollTargetType,\n  index: CounterType,\n  eventHandler: EventHandlerType,\n  percentOfView: PercentOfViewType,\n  loop: boolean,\n  dragFree: boolean,\n  skipSnaps: boolean,\n): DragHandlerType {\n  const { cross: crossAxis } = axis\n  const focusNodes = ['INPUT', 'SELECT', 'TEXTAREA']\n  const dragStartPoint = Vector1D(0)\n  const activationEvents = EventStore()\n  const interactionEvents = EventStore()\n  const dragThreshold = percentOfView.measure(20)\n  const snapForceBoost = { mouse: 300, touch: 400 }\n  const freeForceBoost = { mouse: 500, touch: 600 }\n  const baseSpeed = dragFree ? 5 : 16\n  const baseMass = 1\n\n  let startScroll = 0\n  let startCross = 0\n  let pointerIsDown = false\n  let preventScroll = false\n  let preventClick = false\n  let isMouse = false\n\n  function addActivationEvents(): void {\n    const node = rootNode\n    activationEvents\n      .add(node, 'touchmove', () => undefined)\n      .add(node, 'touchend', () => undefined)\n      .add(node, 'touchstart', down)\n      .add(node, 'mousedown', down)\n      .add(node, 'touchcancel', up)\n      .add(node, 'contextmenu', up)\n      .add(node, 'click', click)\n  }\n\n  function addInteractionEvents(): void {\n    const node = !isMouse ? rootNode : document\n    interactionEvents\n      .add(node, 'touchmove', move)\n      .add(node, 'touchend', up)\n      .add(node, 'mousemove', move)\n      .add(node, 'mouseup', up)\n  }\n\n  function removeAllEvents(): void {\n    activationEvents.removeAll()\n    interactionEvents.removeAll()\n  }\n\n  function isFocusNode(node: Element): boolean {\n    const name = node.nodeName || ''\n    return focusNodes.indexOf(name) > -1\n  }\n\n  function forceBoost(): number {\n    const boost = dragFree ? freeForceBoost : snapForceBoost\n    const type = isMouse ? 'mouse' : 'touch'\n    return boost[type]\n  }\n\n  function allowedForce(force: number, targetChanged: boolean): number {\n    const next = index.clone().add(mathSign(force) * -1)\n    const isEdge = next.get() === index.min || next.get() === index.max\n    const baseForce = scrollTarget.byDistance(force, !dragFree).distance\n\n    if (dragFree || mathAbs(force) < dragThreshold) return baseForce\n    if (!loop && isEdge) return baseForce * 0.4\n    if (skipSnaps && targetChanged) return baseForce * 0.5\n\n    return scrollTarget.byIndex(next.get(), 0).distance\n  }\n\n  function down(evt: PointerEventType): void {\n    isMouse = evt.type === 'mousedown'\n    if (isMouse && (evt as MouseEvent).button !== 0) return\n\n    const isMoving = deltaAbs(target.get(), location.get()) >= 2\n    const clearPreventClick = isMouse || !isMoving\n    const isNotFocusNode = !isFocusNode(evt.target as Element)\n    const preventDefault = isMoving || (isMouse && isNotFocusNode)\n\n    pointerIsDown = true\n    dragTracker.pointerDown(evt)\n    dragStartPoint.set(target)\n    target.set(location)\n    scrollBody.useBaseMass().useSpeed(80)\n    addInteractionEvents()\n    startScroll = dragTracker.readPoint(evt)\n    startCross = dragTracker.readPoint(evt, crossAxis)\n    eventHandler.emit('pointerDown')\n\n    if (clearPreventClick) preventClick = false\n    if (preventDefault) evt.preventDefault()\n  }\n\n  function move(evt: PointerEventType): void {\n    if (!preventScroll && !isMouse) {\n      if (!evt.cancelable) return up(evt)\n      const lastScroll = dragTracker.readPoint(evt)\n      const lastCross = dragTracker.readPoint(evt, crossAxis)\n      const diffScroll = deltaAbs(lastScroll, startScroll)\n      const diffCross = deltaAbs(lastCross, startCross)\n      preventScroll = diffScroll > diffCross\n      if (!preventScroll && !preventClick) return up(evt)\n    }\n    const diff = dragTracker.pointerMove(evt)\n    if (!preventClick && diff) preventClick = true\n    animation.start()\n    target.add(direction.apply(diff))\n    evt.preventDefault()\n  }\n\n  function up(evt: PointerEventType): void {\n    const currentLocation = scrollTarget.byDistance(0, false)\n    const targetChanged = currentLocation.index !== index.get()\n    const rawForce = dragTracker.pointerUp(evt) * forceBoost()\n    const force = allowedForce(direction.apply(rawForce), targetChanged)\n    const forceFactor = factorAbs(rawForce, force)\n    const isMoving = deltaAbs(target.get(), dragStartPoint.get()) >= 0.5\n    const isVigorous = targetChanged && forceFactor > 0.75\n    const isBelowThreshold = mathAbs(rawForce) < dragThreshold\n    const speed = isVigorous ? 10 : baseSpeed\n    const mass = isVigorous ? baseMass + 2.5 * forceFactor : baseMass\n\n    if (isMoving && !isMouse) preventClick = true\n    preventScroll = false\n    pointerIsDown = false\n    interactionEvents.removeAll()\n    scrollBody.useSpeed(isBelowThreshold ? 9 : speed).useMass(mass)\n    scrollTo.distance(force, !dragFree)\n    isMouse = false\n    eventHandler.emit('pointerUp')\n  }\n\n  function click(evt: MouseEvent): void {\n    if (preventClick) evt.preventDefault()\n  }\n\n  function clickAllowed(): boolean {\n    return !preventClick\n  }\n\n  function pointerDown(): boolean {\n    return pointerIsDown\n  }\n\n  const self: DragHandlerType = {\n    addActivationEvents,\n    clickAllowed,\n    pointerDown,\n    removeAllEvents,\n  }\n  return self\n}\n","import { AxisOptionType, AxisType } from './Axis'\nimport { mathAbs } from './utils'\n\ntype PointerCoordType = keyof Touch | keyof MouseEvent\nexport type PointerEventType = TouchEvent | MouseEvent\n\nexport type DragTrackerType = {\n  isTouchEvent: (evt: PointerEventType) => evt is TouchEvent\n  pointerDown: (evt: PointerEventType) => number\n  pointerMove: (evt: PointerEventType) => number\n  pointerUp: (evt: PointerEventType) => number\n  readPoint: (evt: PointerEventType, evtAxis?: AxisOptionType) => number\n}\n\nexport function DragTracker(axis: AxisType): DragTrackerType {\n  const logInterval = 170\n\n  let startEvent: PointerEventType\n  let lastEvent: PointerEventType\n\n  function isTouchEvent(evt: PointerEventType): evt is TouchEvent {\n    return typeof TouchEvent !== 'undefined' && evt instanceof TouchEvent\n  }\n\n  function readTime(evt: PointerEventType): number {\n    return evt.timeStamp\n  }\n\n  function readPoint(evt: PointerEventType, evtAxis?: AxisOptionType): number {\n    const property = evtAxis || axis.scroll\n    const coord: PointerCoordType = `client${property === 'x' ? 'X' : 'Y'}`\n    return (isTouchEvent(evt) ? evt.touches[0] : evt)[coord]\n  }\n\n  function pointerDown(evt: PointerEventType): number {\n    startEvent = evt\n    lastEvent = evt\n    return readPoint(evt)\n  }\n\n  function pointerMove(evt: PointerEventType): number {\n    const diff = readPoint(evt) - readPoint(lastEvent)\n    const expired = readTime(evt) - readTime(startEvent) > logInterval\n\n    lastEvent = evt\n    if (expired) startEvent = evt\n    return diff\n  }\n\n  function pointerUp(evt: PointerEventType): number {\n    if (!startEvent || !lastEvent) return 0\n    const diffDrag = readPoint(lastEvent) - readPoint(startEvent)\n    const diffTime = readTime(evt) - readTime(startEvent)\n    const expired = readTime(evt) - readTime(lastEvent) > logInterval\n    const force = diffDrag / diffTime\n    const isFlick = diffTime && !expired && mathAbs(force) > 0.1\n\n    return isFlick ? force : 0\n  }\n\n  const self: DragTrackerType = {\n    isTouchEvent,\n    pointerDown,\n    pointerMove,\n    pointerUp,\n    readPoint,\n  }\n  return self\n}\n","export type PercentOfViewType = {\n  measure: (n: number) => number\n}\n\nexport function PercentOfView(viewSize: number): PercentOfViewType {\n  function measure(n: number): number {\n    return viewSize * (n / 100)\n  }\n\n  const self: PercentOfViewType = {\n    measure,\n  }\n  return self\n}\n","import { map, roundToDecimals, mathSign } from './utils'\nimport { Vector1D, Vector1DType } from './Vector1d'\n\nexport type ScrollBodyType = {\n  direction: () => number\n  seek: (target: Vector1DType) => ScrollBodyType\n  settle: (target: Vector1DType) => boolean\n  update: () => void\n  useBaseMass: () => ScrollBodyType\n  useBaseSpeed: () => ScrollBodyType\n  useMass: (n: number) => ScrollBodyType\n  useSpeed: (n: number) => ScrollBodyType\n}\n\nexport function ScrollBody(\n  location: Vector1DType,\n  baseSpeed: number,\n  baseMass: number,\n): ScrollBodyType {\n  const roundToTwoDecimals = roundToDecimals(2)\n  const velocity = Vector1D(0)\n  const acceleration = Vector1D(0)\n  const attraction = Vector1D(0)\n\n  let attractionDirection = 0\n  let speed = baseSpeed\n  let mass = baseMass\n\n  function update(): void {\n    velocity.add(acceleration)\n    location.add(velocity)\n    acceleration.multiply(0)\n  }\n\n  function applyForce(force: Vector1DType): void {\n    force.divide(mass)\n    acceleration.add(force)\n  }\n\n  function seek(target: Vector1DType): ScrollBodyType {\n    attraction.set(target).subtract(location)\n    const magnitude = map(attraction.get(), 0, 100, 0, speed)\n    attractionDirection = mathSign(attraction.get())\n    attraction.normalize().multiply(magnitude).subtract(velocity)\n    applyForce(attraction)\n    return self\n  }\n\n  function settle(target: Vector1DType): boolean {\n    const diff = target.get() - location.get()\n    const hasSettled = !roundToTwoDecimals(diff)\n    if (hasSettled) location.set(target)\n    return hasSettled\n  }\n\n  function direction(): number {\n    return attractionDirection\n  }\n\n  function useBaseSpeed(): ScrollBodyType {\n    return useSpeed(baseSpeed)\n  }\n\n  function useBaseMass(): ScrollBodyType {\n    return useMass(baseMass)\n  }\n\n  function useSpeed(n: number): ScrollBodyType {\n    speed = n\n    return self\n  }\n\n  function useMass(n: number): ScrollBodyType {\n    mass = n\n    return self\n  }\n\n  const self: ScrollBodyType = {\n    direction,\n    seek,\n    settle,\n    update,\n    useBaseMass,\n    useBaseSpeed,\n    useMass,\n    useSpeed,\n  }\n  return self\n}\n","import { LimitType } from './Limit'\nimport { ScrollBodyType } from './ScrollBody'\nimport { Vector1DType } from './Vector1d'\nimport { mathAbs } from './utils'\nimport { PercentOfViewType } from './PercentOfView'\n\nexport type ScrollBoundsType = {\n  constrain: (pointerDown: boolean) => void\n  toggleActive: (active: boolean) => void\n}\n\nexport function ScrollBounds(\n  limit: LimitType,\n  location: Vector1DType,\n  target: Vector1DType,\n  scrollBody: ScrollBodyType,\n  percentOfView: PercentOfViewType,\n): ScrollBoundsType {\n  const pullBackThreshold = percentOfView.measure(10)\n  const edgeOffsetTolerance = percentOfView.measure(50)\n  const maxFriction = 0.85\n  let disabled = false\n\n  function shouldConstrain(): boolean {\n    if (disabled) return false\n    if (!limit.reachedAny(target.get())) return false\n    if (!limit.reachedAny(location.get())) return false\n    return true\n  }\n\n  function constrain(pointerDown: boolean): void {\n    if (!shouldConstrain()) return\n    const edge = limit.reachedMin(location.get()) ? 'min' : 'max'\n    const diffToEdge = mathAbs(limit[edge] - location.get())\n    const diffToTarget = target.get() - location.get()\n    const friction = Math.min(diffToEdge / edgeOffsetTolerance, maxFriction)\n\n    target.subtract(diffToTarget * friction)\n\n    if (!pointerDown && mathAbs(diffToTarget) < pullBackThreshold) {\n      target.set(limit.constrain(target.get()))\n      scrollBody.useSpeed(10).useMass(3)\n    }\n  }\n\n  function toggleActive(active: boolean): void {\n    disabled = !active\n  }\n\n  const self: ScrollBoundsType = {\n    constrain,\n    toggleActive,\n  }\n  return self\n}\n","import { Limit, LimitType } from './Limit'\nimport { arrayLast } from './utils'\n\nexport type ScrollContainOptionType = '' | 'trimSnaps' | 'keepSnaps'\n\nexport type ScrollContainType = {\n  snapsContained: number[]\n}\n\nexport function ScrollContain(\n  viewSize: number,\n  contentSize: number,\n  snapsAligned: number[],\n  containScroll: ScrollContainOptionType,\n): ScrollContainType {\n  const scrollBounds = Limit(-contentSize + viewSize, snapsAligned[0])\n  const snapsBounded = snapsAligned.map(scrollBounds.constrain)\n  const snapsContained = measureContained()\n\n  function findDuplicates(): LimitType {\n    const startSnap = snapsBounded[0]\n    const endSnap = arrayLast(snapsBounded)\n    const min = snapsBounded.lastIndexOf(startSnap)\n    const max = snapsBounded.indexOf(endSnap) + 1\n    return Limit(min, max)\n  }\n\n  function measureContained(): number[] {\n    if (contentSize <= viewSize) return [scrollBounds.max]\n    if (containScroll === 'keepSnaps') return snapsBounded\n    const { min, max } = findDuplicates()\n    return snapsBounded.slice(min, max)\n  }\n\n  const self: ScrollContainType = {\n    snapsContained,\n  }\n  return self\n}\n","import { Limit, LimitType } from './Limit'\nimport { arrayLast } from './utils'\n\nexport type ScrollLimitType = {\n  limit: LimitType\n}\n\nexport function ScrollLimit(\n  contentSize: number,\n  scrollSnaps: number[],\n  loop: boolean,\n): ScrollLimitType {\n  const limit = measureLimit()\n\n  function measureLimit(): LimitType {\n    const startSnap = scrollSnaps[0]\n    const endSnap = arrayLast(scrollSnaps)\n    const min = loop ? startSnap - contentSize : endSnap\n    const max = startSnap\n    return Limit(min, max)\n  }\n\n  const self: ScrollLimitType = {\n    limit,\n  }\n  return self\n}\n","import { Limit, LimitType } from './Limit'\nimport { Vector1DType } from './Vector1d'\n\nexport type ScrollLooperType = {\n  loop: (direction: number) => void\n}\n\nexport function ScrollLooper(\n  contentSize: number,\n  limit: LimitType,\n  location: Vector1DType,\n  vectors: Vector1DType[],\n): ScrollLooperType {\n  const jointSafety = 0.1\n  const min = limit.min + jointSafety\n  const max = limit.max + jointSafety\n  const { reachedMin, reachedMax } = Limit(min, max)\n\n  function shouldLoop(direction: number): boolean {\n    if (direction === 1) return reachedMax(location.get())\n    if (direction === -1) return reachedMin(location.get())\n    return false\n  }\n\n  function loop(direction: number): void {\n    if (!shouldLoop(direction)) return\n\n    const loopDistance = contentSize * (direction * -1)\n    vectors.forEach((v) => v.add(loopDistance))\n  }\n\n  const self: ScrollLooperType = {\n    loop,\n  }\n  return self\n}\n","import { LimitType } from './Limit'\n\nexport type ScrollProgressType = {\n  get: (n: number) => number\n}\n\nexport function ScrollProgress(limit: LimitType): ScrollProgressType {\n  const { max, length: scrollLength } = limit\n\n  function get(n: number): number {\n    const currentLocation = n - max\n    return currentLocation / -scrollLength\n  }\n\n  const self: ScrollProgressType = {\n    get,\n  }\n  return self\n}\n","import { AlignmentType } from './Alignment'\nimport { AxisType } from './Axis'\nimport { SlidesToScrollType } from './SlidesToScroll'\nimport { arrayLast, arrayLastIndex, mathAbs } from './utils'\n\nexport type ScrollSnapsType = {\n  snaps: number[]\n  snapsAligned: number[]\n}\n\nexport function ScrollSnaps(\n  axis: AxisType,\n  alignment: AlignmentType,\n  containerRect: DOMRect,\n  slideRects: DOMRect[],\n  slideSizesWithGaps: number[],\n  slidesToScroll: SlidesToScrollType,\n  containScroll: boolean,\n): ScrollSnapsType {\n  const { startEdge, endEdge } = axis\n  const { groupSlides } = slidesToScroll\n  const alignments = measureSizes().map(alignment.measure)\n  const snaps = measureUnaligned()\n  const snapsAligned = measureAligned()\n\n  function measureSizes(): number[] {\n    return groupSlides(slideRects)\n      .map((rects) => arrayLast(rects)[endEdge] - rects[0][startEdge])\n      .map(mathAbs)\n  }\n\n  function measureUnaligned(): number[] {\n    return slideRects\n      .map((rect) => containerRect[startEdge] - rect[startEdge])\n      .map((snap) => -mathAbs(snap))\n  }\n\n  function measureAligned(): number[] {\n    const containedStartSnap = 0\n    const containedEndSnap = arrayLast(snaps) - arrayLast(slideSizesWithGaps)\n\n    return groupSlides(snaps)\n      .map((g) => g[0])\n      .map((snap, index, groupedSnaps) => {\n        const isFirst = !index\n        const isLast = index === arrayLastIndex(groupedSnaps)\n        if (containScroll && isFirst) return containedStartSnap\n        if (containScroll && isLast) return containedEndSnap\n        return snap + alignments[index]\n      })\n  }\n\n  const self: ScrollSnapsType = {\n    snaps,\n    snapsAligned,\n  }\n  return self\n}\n","import { LimitType } from './Limit'\nimport { Vector1DType } from './Vector1d'\nimport { mathAbs, mathSign } from './utils'\n\nexport type TargetType = {\n  distance: number\n  index: number\n}\n\nexport type ScrollTargetType = {\n  byIndex: (target: number, direction: number) => TargetType\n  byDistance: (force: number, snap: boolean) => TargetType\n  shortcut: (target: number, direction: number) => number\n}\n\nexport function ScrollTarget(\n  loop: boolean,\n  scrollSnaps: number[],\n  contentSize: number,\n  limit: LimitType,\n  targetVector: Vector1DType,\n): ScrollTargetType {\n  const { reachedAny, removeOffset, constrain } = limit\n\n  function minDistance(distances: number[]): number {\n    return distances.concat().sort((a, b) => mathAbs(a) - mathAbs(b))[0]\n  }\n\n  function findTargetSnap(target: number): TargetType {\n    const distance = loop ? removeOffset(target) : constrain(target)\n    const ascDiffsToSnaps = scrollSnaps\n      .map((scrollSnap) => scrollSnap - distance)\n      .map((diffToSnap) => shortcut(diffToSnap, 0))\n      .map((diff, i) => ({ diff, index: i }))\n      .sort((d1, d2) => mathAbs(d1.diff) - mathAbs(d2.diff))\n\n    const { index } = ascDiffsToSnaps[0]\n    return { index, distance }\n  }\n\n  function shortcut(target: number, direction: number): number {\n    const targets = [target, target + contentSize, target - contentSize]\n\n    if (!loop) return targets[0]\n    if (!direction) return minDistance(targets)\n\n    const matchingTargets = targets.filter((t) => mathSign(t) === direction)\n    return minDistance(matchingTargets)\n  }\n\n  function byIndex(index: number, direction: number): TargetType {\n    const diffToSnap = scrollSnaps[index] - targetVector.get()\n    const distance = shortcut(diffToSnap, direction)\n    return { index, distance }\n  }\n\n  function byDistance(distance: number, snap: boolean): TargetType {\n    const target = targetVector.get() + distance\n    const { index, distance: targetSnapDistance } = findTargetSnap(target)\n    const reachedBound = !loop && reachedAny(target)\n\n    if (!snap || reachedBound) return { index, distance }\n\n    const diffToSnap = scrollSnaps[index] - targetSnapDistance\n    const snapDistance = distance + shortcut(diffToSnap, 0)\n\n    return { index, distance: snapDistance }\n  }\n\n  const self: ScrollTargetType = {\n    byDistance,\n    byIndex,\n    shortcut,\n  }\n  return self\n}\n","import { AnimationType } from './Animation'\nimport { CounterType } from './Counter'\nimport { EventHandlerType } from './EventHandler'\nimport { ScrollTargetType, TargetType } from './ScrollTarget'\nimport { Vector1DType } from './Vector1d'\n\nexport type ScrollToType = {\n  distance: (n: number, snap: boolean) => void\n  index: (n: number, direction: number) => void\n}\n\nexport function ScrollTo(\n  animation: AnimationType,\n  indexCurrent: CounterType,\n  indexPrevious: CounterType,\n  scrollTarget: ScrollTargetType,\n  targetVector: Vector1DType,\n  eventHandler: EventHandlerType,\n): ScrollToType {\n  function scrollTo(target: TargetType): void {\n    const distanceDiff = target.distance\n    const indexDiff = target.index !== indexCurrent.get()\n\n    if (distanceDiff) {\n      animation.start()\n      targetVector.add(distanceDiff)\n    }\n    if (indexDiff) {\n      indexPrevious.set(indexCurrent.get())\n      indexCurrent.set(target.index)\n      eventHandler.emit('select')\n    }\n  }\n\n  function distance(n: number, snap: boolean): void {\n    const target = scrollTarget.byDistance(n, snap)\n    scrollTo(target)\n  }\n\n  function index(n: number, direction: number): void {\n    const targetIndex = indexCurrent.clone().set(n)\n    const target = scrollTarget.byIndex(targetIndex.get(), direction)\n    scrollTo(target)\n  }\n\n  const self: ScrollToType = {\n    distance,\n    index,\n  }\n  return self\n}\n","import { AxisType } from './Axis'\nimport { DirectionType } from './Direction'\nimport { Vector1DType } from './Vector1d'\n\nexport type TranslateType = {\n  clear: () => void\n  to: (vector: Vector1DType) => void\n  toggleActive: (active: boolean) => void\n}\n\nexport function Translate(\n  axis: AxisType,\n  direction: DirectionType,\n  container: HTMLElement,\n): TranslateType {\n  const translate = axis.scroll === 'x' ? x : y\n  const containerStyle = container.style\n  let disabled = false\n\n  function x(n: number): string {\n    return `translate3d(${n}px,0px,0px)`\n  }\n\n  function y(n: number): string {\n    return `translate3d(0px,${n}px,0px)`\n  }\n\n  function to(target: Vector1DType): void {\n    if (disabled) return\n    containerStyle.transform = translate(direction.apply(target.get()))\n  }\n\n  function toggleActive(active: boolean): void {\n    disabled = !active\n  }\n\n  function clear(): void {\n    if (disabled) return\n    containerStyle.transform = ''\n    if (!container.getAttribute('style')) container.removeAttribute('style')\n  }\n\n  const self: TranslateType = {\n    clear,\n    to,\n    toggleActive,\n  }\n  return self\n}\n","import { AxisType } from './Axis'\nimport { arrayKeys } from './utils'\nimport { SlidesInViewType } from './SlidesInView'\nimport { Vector1D, Vector1DType } from './Vector1d'\nimport { Translate, TranslateType } from './Translate'\nimport { DirectionType } from './Direction'\n\ntype EdgeType = 'start' | 'end'\n\ntype LoopPointType = {\n  index: number\n  translate: TranslateType\n  location: Vector1DType\n  target: () => Vector1DType\n}\n\nexport type SlideLooperType = {\n  canLoop: () => boolean\n  clear: () => void\n  loop: () => void\n  loopPoints: LoopPointType[]\n}\n\nexport function SlideLooper(\n  axis: AxisType,\n  direction: DirectionType,\n  viewSize: number,\n  contentSize: number,\n  slideSizesWithGaps: number[],\n  scrollSnaps: number[],\n  slidesInView: SlidesInViewType,\n  scroll: Vector1DType,\n  slides: HTMLElement[],\n): SlideLooperType {\n  const ascItems = arrayKeys(slideSizesWithGaps)\n  const descItems = arrayKeys(slideSizesWithGaps).reverse()\n  const loopPoints = startPoints().concat(endPoints())\n\n  function removeSlideSizes(indexes: number[], from: number): number {\n    return indexes.reduce((a: number, i) => {\n      return a - slideSizesWithGaps[i]\n    }, from)\n  }\n\n  function slidesInGap(indexes: number[], gap: number): number[] {\n    return indexes.reduce((a: number[], i) => {\n      const remainingGap = removeSlideSizes(a, gap)\n      return remainingGap > 0 ? a.concat([i]) : a\n    }, [])\n  }\n\n  function findLoopPoints(indexes: number[], edge: EdgeType): LoopPointType[] {\n    const isStartEdge = edge === 'start'\n    const offset = isStartEdge ? -contentSize : contentSize\n    const slideBounds = slidesInView.findSlideBounds([offset])\n\n    return indexes.map((index) => {\n      const initial = isStartEdge ? 0 : -contentSize\n      const altered = isStartEdge ? contentSize : 0\n      const bounds = slideBounds.filter((b) => b.index === index)[0]\n      const point = bounds[isStartEdge ? 'end' : 'start']\n      const shift = Vector1D(-1)\n      const location = Vector1D(-1)\n      const translate = Translate(axis, direction, slides[index])\n      const target = () => shift.set(scroll.get() > point ? initial : altered)\n      return { index, location, translate, target }\n    })\n  }\n\n  function startPoints(): LoopPointType[] {\n    const gap = scrollSnaps[0] - 1\n    const indexes = slidesInGap(descItems, gap)\n    return findLoopPoints(indexes, 'end')\n  }\n\n  function endPoints(): LoopPointType[] {\n    const gap = viewSize - scrollSnaps[0] - 1\n    const indexes = slidesInGap(ascItems, gap)\n    return findLoopPoints(indexes, 'start')\n  }\n\n  function canLoop(): boolean {\n    return loopPoints.every(({ index }) => {\n      const otherIndexes = ascItems.filter((i) => i !== index)\n      return removeSlideSizes(otherIndexes, viewSize) <= 0.1\n    })\n  }\n\n  function loop(): void {\n    loopPoints.forEach((loopPoint) => {\n      const { target, translate, location } = loopPoint\n      const shift = target()\n      if (shift.get() === location.get()) return\n      if (shift.get() === 0) translate.clear()\n      else translate.to(shift)\n      location.set(shift)\n    })\n  }\n\n  function clear(): void {\n    loopPoints.forEach((loopPoint) => loopPoint.translate.clear())\n  }\n\n  const self: SlideLooperType = {\n    canLoop,\n    clear,\n    loop,\n    loopPoints,\n  }\n  return self\n}\n","import { Limit, LimitType } from './Limit'\n\nexport type SlideBoundType = {\n  start: number\n  end: number\n  index: number\n}\n\nexport type SlidesInViewType = {\n  check: (location: number, bounds?: SlideBoundType[]) => number[]\n  findSlideBounds: (offsets?: number[], threshold?: number) => SlideBoundType[]\n}\n\nexport function SlidesInView(\n  viewSize: number,\n  contentSize: number,\n  slideSizes: number[],\n  snaps: number[],\n  limit: LimitType,\n  loop: boolean,\n  inViewThreshold: number,\n): SlidesInViewType {\n  const { removeOffset, constrain } = limit\n  const roundingSafety = 0.5\n  const cachedOffsets = loop ? [0, contentSize, -contentSize] : [0]\n  const cachedBounds = findSlideBounds(cachedOffsets, inViewThreshold)\n\n  function findSlideThresholds(threshold?: number): number[] {\n    const slideThreshold = threshold || 0\n\n    return slideSizes.map((slideSize) => {\n      const thresholdLimit = Limit(roundingSafety, slideSize - roundingSafety)\n      return thresholdLimit.constrain(slideSize * slideThreshold)\n    })\n  }\n\n  function findSlideBounds(\n    offsets?: number[],\n    threshold?: number,\n  ): SlideBoundType[] {\n    const slideOffsets = offsets || cachedOffsets\n    const slideThresholds = findSlideThresholds(threshold)\n\n    return slideOffsets.reduce((list: SlideBoundType[], offset) => {\n      const bounds = snaps.map((snap, index) => ({\n        start: snap - slideSizes[index] + slideThresholds[index] + offset,\n        end: snap + viewSize - slideThresholds[index] + offset,\n        index,\n      }))\n      return list.concat(bounds)\n    }, [])\n  }\n\n  function check(location: number, bounds?: SlideBoundType[]): number[] {\n    const limitedLocation = loop ? removeOffset(location) : constrain(location)\n    const slideBounds = bounds || cachedBounds\n\n    return slideBounds.reduce((list: number[], slideBound) => {\n      const { index, start, end } = slideBound\n      const inList = list.indexOf(index) !== -1\n      const inView = start < limitedLocation && end > limitedLocation\n      return !inList && inView ? list.concat([index]) : list\n    }, [])\n  }\n\n  const self: SlidesInViewType = {\n    check,\n    findSlideBounds,\n  }\n  return self\n}\n","import { AxisType } from './Axis'\nimport { arrayLast, arrayLastIndex, mathAbs } from './utils'\n\nexport type SlideSizesType = {\n  slideSizes: number[]\n  slideSizesWithGaps: number[]\n}\n\nexport function SlideSizes(\n  axis: AxisType,\n  containerRect: DOMRect,\n  slideRects: DOMRect[],\n  slides: HTMLElement[],\n  includeEdgeGap: boolean,\n): SlideSizesType {\n  const { measureSize, startEdge, endEdge } = axis\n  const startGap = measureStartGap()\n  const endGap = measureEndGap()\n  const slideSizes = slideRects.map(measureSize)\n  const slideSizesWithGaps = measureWithGaps()\n\n  function measureStartGap(): number {\n    if (!includeEdgeGap) return 0\n    const slideRect = slideRects[0]\n    return mathAbs(containerRect[startEdge] - slideRect[startEdge])\n  }\n\n  function measureEndGap(): number {\n    if (!includeEdgeGap) return 0\n    const style = window.getComputedStyle(arrayLast(slides))\n    return parseFloat(style.getPropertyValue(`margin-${endEdge}`))\n  }\n\n  function measureWithGaps(): number[] {\n    return slideRects\n      .map((rect, index, rects) => {\n        const isFirst = !index\n        const isLast = index === arrayLastIndex(rects)\n        if (isFirst) return slideSizes[index] + startGap\n        if (isLast) return slideSizes[index] + endGap\n        return rects[index + 1][startEdge] - rect[startEdge]\n      })\n      .map(mathAbs)\n  }\n\n  const self: SlideSizesType = {\n    slideSizes,\n    slideSizesWithGaps,\n  }\n  return self\n}\n","import { arrayKeys, arrayLast, isNumber } from './utils'\n\nexport type SlidesToScrollOptionType = 'auto' | number\n\nexport type SlidesToScrollType = {\n  groupSlides: <Type>(array: Type[]) => Type[][]\n}\n\nexport function SlidesToScroll(\n  viewSize: number,\n  slideSizesWithGaps: number[],\n  slidesToScroll: SlidesToScrollOptionType,\n): SlidesToScrollType {\n  const groupByNumber = isNumber(slidesToScroll)\n\n  function byNumber<Type>(array: Type[], groupSize: number): Type[][] {\n    return arrayKeys(array)\n      .filter((i) => i % groupSize === 0)\n      .map((i) => array.slice(i, i + groupSize))\n  }\n\n  function bySize<Type>(array: Type[]): Type[][] {\n    return arrayKeys(array)\n      .reduce((groupSizes: number[], i) => {\n        const chunk = slideSizesWithGaps.slice(arrayLast(groupSizes), i + 1)\n        const chunkSize = chunk.reduce((a, s) => a + s, 0)\n        return !i || chunkSize > viewSize ? groupSizes.concat(i) : groupSizes\n      }, [])\n      .map((start, i, groupSizes) => array.slice(start, groupSizes[i + 1]))\n  }\n\n  function groupSlides<Type>(array: Type[]): Type[][] {\n    return groupByNumber ? byNumber(array, slidesToScroll) : bySize(array)\n  }\n\n  const self: SlidesToScrollType = {\n    groupSlides,\n  }\n  return self\n}\n","import { Alignment } from './Alignment'\nimport { Animation, AnimationType } from './Animation'\nimport { Axis, AxisType } from './Axis'\nimport { Counter, CounterType } from './Counter'\nimport { Direction, DirectionType } from './Direction'\nimport { DragHandler, DragHandlerType } from './DragHandler'\nimport { DragTracker } from './DragTracker'\nimport { EventHandlerType } from './EventHandler'\nimport { EventStore, EventStoreType } from './EventStore'\nimport { LimitType } from './Limit'\nimport { OptionsType } from './Options'\nimport { PercentOfView, PercentOfViewType } from './PercentOfView'\nimport { ScrollBody, ScrollBodyType } from './ScrollBody'\nimport { ScrollBounds, ScrollBoundsType } from './ScrollBounds'\nimport { ScrollContain } from './ScrollContain'\nimport { ScrollLimit } from './ScrollLimit'\nimport { ScrollLooper, ScrollLooperType } from './ScrollLooper'\nimport { ScrollProgress, ScrollProgressType } from './ScrollProgress'\nimport { ScrollSnaps } from './ScrollSnaps'\nimport { ScrollTarget, ScrollTargetType } from './ScrollTarget'\nimport { ScrollTo, ScrollToType } from './ScrollTo'\nimport { SlideLooper, SlideLooperType } from './SlideLooper'\nimport { SlidesInView, SlidesInViewType } from './SlidesInView'\nimport { SlideSizes } from './SlideSizes'\nimport { SlidesToScroll, SlidesToScrollType } from './SlidesToScroll'\nimport { Translate, TranslateType } from './Translate'\nimport { arrayKeys, arrayLast, arrayLastIndex } from './utils'\nimport { Vector1D, Vector1DType } from './Vector1d'\n\nexport type EngineType = {\n  axis: AxisType\n  direction: DirectionType\n  animation: AnimationType\n  scrollBounds: ScrollBoundsType\n  scrollLooper: ScrollLooperType\n  scrollProgress: ScrollProgressType\n  index: CounterType\n  indexPrevious: CounterType\n  limit: LimitType\n  location: Vector1DType\n  options: OptionsType\n  percentOfView: PercentOfViewType\n  scrollBody: ScrollBodyType\n  dragHandler: DragHandlerType\n  eventStore: EventStoreType\n  slideLooper: SlideLooperType\n  slidesInView: SlidesInViewType\n  slidesToScroll: SlidesToScrollType\n  target: Vector1DType\n  translate: TranslateType\n  scrollTo: ScrollToType\n  scrollTarget: ScrollTargetType\n  scrollSnaps: number[]\n  slideIndexes: number[]\n  containerRect: DOMRect\n  slideRects: DOMRect[]\n}\n\nexport function Engine(\n  root: HTMLElement,\n  container: HTMLElement,\n  slides: HTMLElement[],\n  options: OptionsType,\n  eventHandler: EventHandlerType,\n): EngineType {\n  // Options\n  const {\n    align,\n    axis: scrollAxis,\n    direction: contentDirection,\n    startIndex,\n    inViewThreshold,\n    loop,\n    speed,\n    dragFree,\n    slidesToScroll: groupSlides,\n    skipSnaps,\n    containScroll,\n  } = options\n\n  // Measurements\n  const containerRect = container.getBoundingClientRect()\n  const slideRects = slides.map((slide) => slide.getBoundingClientRect())\n  const direction = Direction(contentDirection)\n  const axis = Axis(scrollAxis, contentDirection)\n  const viewSize = axis.measureSize(containerRect)\n  const percentOfView = PercentOfView(viewSize)\n  const alignment = Alignment(align, viewSize)\n  const containSnaps = !loop && containScroll !== ''\n  const includeEdgeGap = loop || containScroll !== ''\n  const { slideSizes, slideSizesWithGaps } = SlideSizes(\n    axis,\n    containerRect,\n    slideRects,\n    slides,\n    includeEdgeGap,\n  )\n  const slidesToScroll = SlidesToScroll(\n    viewSize,\n    slideSizesWithGaps,\n    groupSlides,\n  )\n  const { snaps, snapsAligned } = ScrollSnaps(\n    axis,\n    alignment,\n    containerRect,\n    slideRects,\n    slideSizesWithGaps,\n    slidesToScroll,\n    containSnaps,\n  )\n  const contentSize = -arrayLast(snaps) + arrayLast(slideSizesWithGaps)\n  const { snapsContained } = ScrollContain(\n    viewSize,\n    contentSize,\n    snapsAligned,\n    containScroll,\n  )\n  const scrollSnaps = containSnaps ? snapsContained : snapsAligned\n  const { limit } = ScrollLimit(contentSize, scrollSnaps, loop)\n\n  // Indexes\n  const index = Counter(arrayLastIndex(scrollSnaps), startIndex, loop)\n  const indexPrevious = index.clone()\n  const slideIndexes = arrayKeys(slides)\n\n  // Draw\n  const update = (): void => {\n    if (!loop) engine.scrollBounds.constrain(engine.dragHandler.pointerDown())\n    engine.scrollBody.seek(target).update()\n    const settled = engine.scrollBody.settle(target)\n\n    if (settled && !engine.dragHandler.pointerDown()) {\n      engine.animation.stop()\n      eventHandler.emit('settle')\n    }\n    if (!settled) {\n      eventHandler.emit('scroll')\n    }\n    if (loop) {\n      engine.scrollLooper.loop(engine.scrollBody.direction())\n      engine.slideLooper.loop()\n    }\n\n    engine.translate.to(location)\n    engine.animation.proceed()\n  }\n\n  // Shared\n  const animation = Animation(update)\n  const startLocation = scrollSnaps[index.get()]\n  const location = Vector1D(startLocation)\n  const target = Vector1D(startLocation)\n  const scrollBody = ScrollBody(location, speed, 1)\n  const scrollTarget = ScrollTarget(\n    loop,\n    scrollSnaps,\n    contentSize,\n    limit,\n    target,\n  )\n  const scrollTo = ScrollTo(\n    animation,\n    index,\n    indexPrevious,\n    scrollTarget,\n    target,\n    eventHandler,\n  )\n  const slidesInView = SlidesInView(\n    viewSize,\n    contentSize,\n    slideSizes,\n    snaps,\n    limit,\n    loop,\n    inViewThreshold,\n  )\n\n  // DragHandler\n  const dragHandler = DragHandler(\n    axis,\n    direction,\n    root,\n    target,\n    DragTracker(axis),\n    location,\n    animation,\n    scrollTo,\n    scrollBody,\n    scrollTarget,\n    index,\n    eventHandler,\n    percentOfView,\n    loop,\n    dragFree,\n    skipSnaps,\n  )\n\n  // Engine\n  const engine: EngineType = {\n    containerRect,\n    slideRects,\n    animation,\n    axis,\n    direction,\n    dragHandler,\n    eventStore: EventStore(),\n    percentOfView,\n    index,\n    indexPrevious,\n    limit,\n    location,\n    options,\n    scrollBody,\n    scrollBounds: ScrollBounds(\n      limit,\n      location,\n      target,\n      scrollBody,\n      percentOfView,\n    ),\n    scrollLooper: ScrollLooper(contentSize, limit, location, [\n      location,\n      target,\n    ]),\n    scrollProgress: ScrollProgress(limit),\n    scrollSnaps,\n    scrollTarget,\n    scrollTo,\n    slideLooper: SlideLooper(\n      axis,\n      direction,\n      viewSize,\n      contentSize,\n      slideSizesWithGaps,\n      scrollSnaps,\n      slidesInView,\n      location,\n      slides,\n    ),\n    slidesToScroll,\n    slidesInView,\n    slideIndexes,\n    target,\n    translate: Translate(axis, direction, container),\n  }\n  return engine\n}\n","type CallbackType = (evt: EmblaEventType) => void\ntype ListenersType = Partial<{ [key in EmblaEventType]: CallbackType[] }>\n\nexport type EmblaEventType =\n  | 'init'\n  | 'pointerDown'\n  | 'pointerUp'\n  | 'scroll'\n  | 'select'\n  | 'settle'\n  | 'destroy'\n  | 'reInit'\n  | 'resize'\n\nexport type EventHandlerType = {\n  emit: (evt: EmblaEventType) => EventHandlerType\n  on: (evt: EmblaEventType, cb: CallbackType) => EventHandlerType\n  off: (evt: EmblaEventType, cb: CallbackType) => EventHandlerType\n}\n\nexport function EventHandler(): EventHandlerType {\n  const listeners: ListenersType = {}\n\n  function getListeners(evt: EmblaEventType): CallbackType[] {\n    return listeners[evt] || []\n  }\n\n  function emit(evt: EmblaEventType): EventHandlerType {\n    getListeners(evt).forEach((e) => e(evt))\n    return self\n  }\n\n  function on(evt: EmblaEventType, cb: CallbackType): EventHandlerType {\n    listeners[evt] = getListeners(evt).concat([cb])\n    return self\n  }\n\n  function off(evt: EmblaEventType, cb: CallbackType): EventHandlerType {\n    listeners[evt] = getListeners(evt).filter((e) => e !== cb)\n    return self\n  }\n\n  const self: EventHandlerType = {\n    emit,\n    off,\n    on,\n  }\n  return self\n}\n","import { AlignmentOptionType } from './Alignment'\nimport { AxisOptionType } from './Axis'\nimport { SlidesToScrollOptionType } from './SlidesToScroll'\nimport { DirectionOptionType } from './Direction'\nimport { ScrollContainOptionType } from './ScrollContain'\n\nexport type LooseOptionsType = {\n  [key: string]: unknown\n}\n\nexport type CreateOptionsType<Type extends LooseOptionsType> = Type & {\n  active: boolean\n  breakpoints: {\n    [key: string]: Omit<Partial<CreateOptionsType<Type>>, 'breakpoints'>\n  }\n}\n\nexport type OptionsType = CreateOptionsType<{\n  align: AlignmentOptionType\n  axis: AxisOptionType\n  containScroll: ScrollContainOptionType\n  direction: DirectionOptionType\n  slidesToScroll: SlidesToScrollOptionType\n  dragFree: boolean\n  draggable: boolean\n  inViewThreshold: number\n  loop: boolean\n  skipSnaps: boolean\n  speed: number\n  startIndex: number\n}>\n\nexport const defaultOptions: OptionsType = {\n  align: 'center',\n  axis: 'x',\n  containScroll: '',\n  direction: 'ltr',\n  slidesToScroll: 1,\n  breakpoints: {},\n  dragFree: false,\n  draggable: true,\n  inViewThreshold: 0,\n  loop: false,\n  skipSnaps: false,\n  speed: 10,\n  startIndex: 0,\n  active: true,\n}\n\nexport type EmblaOptionsType = Partial<OptionsType>\n","import { LooseOptionsType, CreateOptionsType } from './Options'\nimport { objectKeys, objectsAreEqual, objectsMergeDeep } from './utils'\n\ntype OptionsType = Partial<CreateOptionsType<LooseOptionsType>>\n\nexport type OptionsHandlerType = {\n  merge: <TypeA extends OptionsType, TypeB extends OptionsType>(\n    optionsA: TypeA,\n    optionsB?: TypeB,\n  ) => TypeA\n  areEqual: <TypeA extends OptionsType, TypeB extends OptionsType>(\n    optionsA: TypeA,\n    optionsB: TypeB,\n  ) => boolean\n  atMedia: <Type extends OptionsType>(options: Type) => Type\n}\n\nexport function OptionsHandler(): OptionsHandlerType {\n  function merge<TypeA extends OptionsType, TypeB extends OptionsType>(\n    optionsA: TypeA,\n    optionsB?: TypeB,\n  ): TypeA {\n    return <TypeA>objectsMergeDeep(optionsA, optionsB || {})\n  }\n\n  function areEqual<TypeA extends OptionsType, TypeB extends OptionsType>(\n    optionsA: TypeA,\n    optionsB: TypeB,\n  ): boolean {\n    const breakpointsA = JSON.stringify(objectKeys(optionsA.breakpoints || {}))\n    const breakpointsB = JSON.stringify(objectKeys(optionsB.breakpoints || {}))\n    if (breakpointsA !== breakpointsB) return false\n    return objectsAreEqual(optionsA, optionsB)\n  }\n\n  function atMedia<Type extends OptionsType>(options: Type): Type {\n    const optionsAtMedia = options.breakpoints || {}\n    const matchedMediaOptions = objectKeys(optionsAtMedia)\n      .filter((media) => window.matchMedia(media).matches)\n      .map((media) => optionsAtMedia[media])\n      .reduce((a, mediaOption) => merge(a, mediaOption), {})\n\n    return merge(options, matchedMediaOptions)\n  }\n\n  const self: OptionsHandlerType = {\n    merge,\n    areEqual,\n    atMedia,\n  }\n  return self\n}\n","import { EmblaCarouselType } from '.'\nimport { OptionsHandler } from './OptionsHandler'\nimport { EmblaPluginsType, EmblaPluginType } from './Plugins'\n\ntype PluginChangedHandlerType = () => boolean\n\nexport type PluginsHandlerType = {\n  init: (\n    plugins: EmblaPluginType[],\n    embla: EmblaCarouselType,\n  ) => EmblaPluginsType\n  destroy: () => void\n  haveChanged: PluginChangedHandlerType\n}\n\nexport function PluginsHandler(): PluginsHandlerType {\n  const { atMedia, areEqual } = OptionsHandler()\n  let activePlugins: EmblaPluginType[] = []\n  let pluginsChanged: PluginChangedHandlerType[] = []\n\n  function haveChanged(): boolean {\n    return pluginsChanged.some((hasChanged) => hasChanged())\n  }\n\n  function hasChanged(plugin: EmblaPluginType): PluginChangedHandlerType {\n    const options = atMedia(plugin.options)\n    return (): boolean => !areEqual(options, atMedia(plugin.options))\n  }\n\n  function init(\n    plugins: EmblaPluginType[],\n    embla: EmblaCarouselType,\n  ): EmblaPluginsType {\n    pluginsChanged = plugins.map(hasChanged)\n    activePlugins = plugins.filter((plugin) => atMedia(plugin.options).active)\n    activePlugins.forEach((plugin) => plugin.init(embla))\n\n    return plugins.reduce((map, plugin) => {\n      return Object.assign(map, { [plugin.name]: plugin })\n    }, {})\n  }\n\n  function destroy(): void {\n    activePlugins = activePlugins.filter((plugin) => plugin.destroy())\n  }\n\n  const self: PluginsHandlerType = {\n    init,\n    destroy,\n    haveChanged,\n  }\n  return self\n}\n","import { Engine, EngineType } from './Engine'\nimport { EventStore } from './EventStore'\nimport { EventHandler, EventHandlerType } from './EventHandler'\nimport { defaultOptions, EmblaOptionsType } from './Options'\nimport { OptionsHandler } from './OptionsHandler'\nimport { PluginsHandler } from './PluginsHandler'\nimport { EmblaPluginsType, EmblaPluginType } from './Plugins'\n\nexport type EmblaNodesType = {\n  root: HTMLElement\n  container?: HTMLElement\n  slides?: HTMLElement[]\n}\n\nexport type EmblaCarouselType = {\n  canScrollNext: () => boolean\n  canScrollPrev: () => boolean\n  clickAllowed: () => boolean\n  containerNode: () => HTMLElement\n  internalEngine: () => EngineType\n  destroy: () => void\n  off: EventHandlerType['off']\n  on: EventHandlerType['on']\n  plugins: () => EmblaPluginsType\n  previousScrollSnap: () => number\n  reInit: (options?: EmblaOptionsType, plugins?: EmblaPluginType[]) => void\n  rootNode: () => HTMLElement\n  scrollNext: (jump?: boolean) => void\n  scrollPrev: (jump?: boolean) => void\n  scrollProgress: () => number\n  scrollSnapList: () => number[]\n  scrollTo: (index: number, jump?: boolean) => void\n  selectedScrollSnap: () => number\n  slideNodes: () => HTMLElement[]\n  slidesInView: (target?: boolean) => number[]\n  slidesNotInView: (target?: boolean) => number[]\n}\n\nfunction EmblaCarousel(\n  nodes: HTMLElement | EmblaNodesType,\n  userOptions?: EmblaOptionsType,\n  userPlugins?: EmblaPluginType[],\n): EmblaCarouselType {\n  const resizeHandlers = EventStore()\n  const optionsHandler = OptionsHandler()\n  const pluginsHandler = PluginsHandler()\n  const eventHandler = EventHandler()\n  const { on, off } = eventHandler\n  const reInit = reActivate\n\n  let destroyed = false\n  let engine: EngineType\n  let optionsBase = optionsHandler.merge(\n    defaultOptions,\n    EmblaCarousel.globalOptions,\n  )\n  let options = optionsHandler.merge(optionsBase)\n  let pluginList: EmblaPluginType[] = []\n  let pluginApis: EmblaPluginsType\n  let rootSize = 0\n  let root: HTMLElement\n  let container: HTMLElement\n  let slides: HTMLElement[]\n\n  function storeElements(): void {\n    const providedContainer = 'container' in nodes && nodes.container\n    const providedSlides = 'slides' in nodes && nodes.slides\n\n    root = 'root' in nodes ? nodes.root : nodes\n    container = providedContainer || <HTMLElement>root.children[0]\n    slides = providedSlides || [].slice.call(container.children)\n  }\n\n  function activate(\n    withOptions?: EmblaOptionsType,\n    withPlugins?: EmblaPluginType[],\n  ): void {\n    if (destroyed) return\n    storeElements()\n\n    optionsBase = optionsHandler.merge(optionsBase, withOptions)\n    options = optionsHandler.atMedia(optionsBase)\n    engine = Engine(root, container, slides, options, eventHandler)\n    rootSize = engine.axis.measureSize(root.getBoundingClientRect())\n\n    if (!options.active) return deActivate()\n\n    engine.translate.to(engine.location)\n    pluginList = withPlugins || pluginList\n    pluginApis = pluginsHandler.init(pluginList, self)\n\n    if (options.loop) {\n      if (!engine.slideLooper.canLoop()) {\n        deActivate()\n        return activate({ loop: false }, withPlugins)\n      }\n      engine.slideLooper.loop()\n    }\n    if (options.draggable && container.offsetParent && slides.length) {\n      engine.dragHandler.addActivationEvents()\n    }\n  }\n\n  function reActivate(\n    withOptions?: EmblaOptionsType,\n    withPlugins?: EmblaPluginType[],\n  ): void {\n    const startIndex = selectedScrollSnap()\n    deActivate()\n    activate(optionsHandler.merge({ startIndex }, withOptions), withPlugins)\n    eventHandler.emit('reInit')\n  }\n\n  function deActivate(): void {\n    engine.dragHandler.removeAllEvents()\n    engine.animation.stop()\n    engine.eventStore.removeAll()\n    engine.translate.clear()\n    engine.slideLooper.clear()\n    pluginsHandler.destroy()\n  }\n\n  function destroy(): void {\n    if (destroyed) return\n    destroyed = true\n    resizeHandlers.removeAll()\n    deActivate()\n    eventHandler.emit('destroy')\n  }\n\n  function resize(): void {\n    const newOptions = optionsHandler.atMedia(optionsBase)\n    const optionsChanged = !optionsHandler.areEqual(newOptions, options)\n    const newRootSize = engine.axis.measureSize(root.getBoundingClientRect())\n    const rootSizeChanged = rootSize !== newRootSize\n    const pluginsChanged = pluginsHandler.haveChanged()\n\n    if (rootSizeChanged || optionsChanged || pluginsChanged) reActivate()\n    eventHandler.emit('resize')\n  }\n\n  function slidesInView(target?: boolean): number[] {\n    const location = engine[target ? 'target' : 'location'].get()\n    const type = options.loop ? 'removeOffset' : 'constrain'\n    return engine.slidesInView.check(engine.limit[type](location))\n  }\n\n  function slidesNotInView(target?: boolean): number[] {\n    const inView = slidesInView(target)\n    return engine.slideIndexes.filter((index) => inView.indexOf(index) === -1)\n  }\n\n  function scrollTo(index: number, jump?: boolean, direction?: number): void {\n    if (!options.active || destroyed) return\n    engine.scrollBody.useBaseMass().useSpeed(jump ? 100 : options.speed)\n    engine.scrollTo.index(index, direction || 0)\n  }\n\n  function scrollNext(jump?: boolean): void {\n    const next = engine.index.clone().add(1)\n    scrollTo(next.get(), jump === true, -1)\n  }\n\n  function scrollPrev(jump?: boolean): void {\n    const prev = engine.index.clone().add(-1)\n    scrollTo(prev.get(), jump === true, 1)\n  }\n\n  function canScrollNext(): boolean {\n    const next = engine.index.clone().add(1)\n    return next.get() !== selectedScrollSnap()\n  }\n\n  function canScrollPrev(): boolean {\n    const prev = engine.index.clone().add(-1)\n    return prev.get() !== selectedScrollSnap()\n  }\n\n  function scrollSnapList(): number[] {\n    return engine.scrollSnaps.map(engine.scrollProgress.get)\n  }\n\n  function scrollProgress(): number {\n    return engine.scrollProgress.get(engine.location.get())\n  }\n\n  function selectedScrollSnap(): number {\n    return engine.index.get()\n  }\n\n  function previousScrollSnap(): number {\n    return engine.indexPrevious.get()\n  }\n\n  function clickAllowed(): boolean {\n    return engine.dragHandler.clickAllowed()\n  }\n\n  function plugins(): EmblaPluginsType {\n    return pluginApis\n  }\n\n  function internalEngine(): EngineType {\n    return engine\n  }\n\n  function rootNode(): HTMLElement {\n    return root\n  }\n\n  function containerNode(): HTMLElement {\n    return container\n  }\n\n  function slideNodes(): HTMLElement[] {\n    return slides\n  }\n\n  const self: EmblaCarouselType = {\n    canScrollNext,\n    canScrollPrev,\n    clickAllowed,\n    containerNode,\n    internalEngine,\n    destroy,\n    off,\n    on,\n    plugins,\n    previousScrollSnap,\n    reInit,\n    rootNode,\n    scrollNext,\n    scrollPrev,\n    scrollProgress,\n    scrollSnapList,\n    scrollTo,\n    selectedScrollSnap,\n    slideNodes,\n    slidesInView,\n    slidesNotInView,\n  }\n\n  activate(userOptions, userPlugins)\n  resizeHandlers.add(window, 'resize', resize)\n  setTimeout(() => eventHandler.emit('init'), 0)\n  return self\n}\n\nEmblaCarousel.globalOptions = <EmblaOptionsType | undefined>undefined\nEmblaCarousel.optionsHandler = OptionsHandler\n\nexport default EmblaCarousel\n"]},"metadata":{},"sourceType":"module"}